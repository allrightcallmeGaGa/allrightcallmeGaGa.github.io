<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>K210摄像头学习笔记 | 嗨！这里是康康的裤兜</title><meta name="author" content="GaGa"><meta name="copyright" content="GaGa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、启用并初始化摄像头代码实例：import sensor, lcd  sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames()  lcd.init(freq&#x3D;15000000)  while(True):     l">
<meta property="og:type" content="article">
<meta property="og:title" content="K210摄像头学习笔记">
<meta property="og:url" content="http://example.com/2023/09/19/K210%E6%91%84%E5%83%8F%E5%A4%B4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="嗨！这里是康康的裤兜">
<meta property="og:description" content="一、启用并初始化摄像头代码实例：import sensor, lcd  sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames()  lcd.init(freq&#x3D;15000000)  while(True):     l">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_1.webp">
<meta property="article:published_time" content="2023-09-19T08:25:00.000Z">
<meta property="article:modified_time" content="2023-09-19T08:33:12.524Z">
<meta property="article:author" content="GaGa">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_1.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/09/19/K210%E6%91%84%E5%83%8F%E5%A4%B4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top_right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'K210摄像头学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-19 16:33:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/bear.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://source.fomal.cc/img/default_cover_1.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="嗨！这里是康康的裤兜"><span class="site-name">嗨！这里是康康的裤兜</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">K210摄像头学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-19T08:25:00.000Z" title="发表于 2023-09-19 16:25:00">2023-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-19T08:33:12.524Z" title="更新于 2023-09-19 16:33:12">2023-09-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>76分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="K210摄像头学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、启用并初始化摄像头"><a href="#一、启用并初始化摄像头" class="headerlink" title="一、启用并初始化摄像头"></a>一、启用并初始化摄像头</h1><h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><pre><code class="python">import sensor, lcd

sensor.reset()
sensor.set_pixformat(sensor.RGB565)
sensor.set_framesize(sensor.QVGA)
sensor.run(1)
sensor.skip_frames()

lcd.init(freq=15000000)

while(True):
    lcd.display(sensor.snapshot())
</code></pre>
<h2 id="引入了对库的使用"><a href="#引入了对库的使用" class="headerlink" title="引入了对库的使用"></a>引入了对库的使用</h2><ul>
<li><p><code>import sensor, lcd</code>:首先是将sensor, lcd两个内置库进行导入</p>
</li>
<li><p><code>sensor.reset()</code>:初始化摄像头</p>
<blockquote>
<p>如果初始化失败要检查硬件损坏和兼容的问题；</p>
</blockquote>
</li>
<li><p><code>sensor.set_pixformat(sensor.RGB565)</code>: 设置摄像头为<code>RGB565</code>格式</p>
<p>  默认都是用<code>RGB565</code>即可</p>
</li>
<li><p><code>sensor.run(1)</code>：摄像头启动！</p>
<p>  可省略，因为完成前三项的设置后，摄像头会自动启动</p>
</li>
<li><p><code>sensor.skip_frames()</code>：skip（跳过），用于跳过摄像头刚启动时的不稳定画面</p>
</li>
<li><p><code>lcd.init(freq=15000000)</code>：初始化LCD，并设置频率</p>
</li>
<li><p><code>lcd.display(sensor.snapshot())</code>：<code>sensor.snapshot()</code>用于获取图像，<code>lcd.display()</code>将图像显示到LCD</p>
</li>
</ul>
<p>Python程序中对库的导入理解上可以对比于C、C++程序中的<code>#include</code>,但不同于C、C++，得益于Python统一的包管理器，Python中的<code>import</code>语句相当于引用了外部程序的特定功能，而C语言中的<code>#include</code>指令相当于在程序前面展开头文件的内容。需要注意的是，Python中的<code>import</code>语句是在程序运行时动态导入模块的，而C语言中的<code>#include</code>指令是在编译时静态的将头文件内容包含在源代码中，这就意味着，在Python中，**<code>import</code><strong>语句可以在程序的任意位置多次使用，而在C语言中，</strong><code>#include</code>**指令多数只能放在源代码开头。</p>
<h2 id="上电操作"><a href="#上电操作" class="headerlink" title="上电操作"></a>上电操作</h2><ul>
<li><p>开发板上电后，打开串口终端</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c270a75-d207-4f45-857c-9a0c66e152a9/Untitled.png" alt="Untitled"></p>
</li>
<li><p>按键盘<code>Ctrl+E</code>,然后将复制好的代码，用鼠标右键粘贴进来，按键盘<code>Ctrl+D</code>来开始运行代码</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6af29bf-b857-40ed-8b67-33463baf0f10/Untitled.png" alt="Untitled"></p>
</li>
<li></li>
</ul>
<h1 id="二、MicroPython-背景知识"><a href="#二、MicroPython-背景知识" class="headerlink" title="二、MicroPython 背景知识"></a>二、<strong>MicroPython 背景知识</strong></h1><h2 id="Python代码素养"><a href="#Python代码素养" class="headerlink" title="Python代码素养"></a>Python代码素养</h2><h3 id="Python语法"><a href="#Python语法" class="headerlink" title="Python语法"></a>Python语法</h3><ul>
<li>两个字：<strong>缩进</strong></li>
</ul>
<pre><code class="python"># print absolute value of an integer:
a = 100
if a &gt;= 0:
    print(a)
else:
    print(-a)
</code></pre>
<p>以<code>#</code>开头的语句是注释。其他每一行都是一个语句，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。注意：Python对大小写是有区分的。</p>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><ul>
<li>统一使用 4 个空格进行缩进</li>
<li>详细语法见 <strong>#2.2MicroPython（Python3） 基本语法</strong></li>
</ul>
<h3 id="行宽"><a href="#行宽" class="headerlink" title="行宽"></a>行宽</h3><ul>
<li>每行代码尽量不超过 80 个字符</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li>模块级函数和类定义之间空两行；</li>
<li>类成员函数之间空一行；</li>
</ul>
<pre><code class="python">class A:

    def __init__(self):
        pass

    def hello(self):
        pass

def main():
    pass
</code></pre>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>Python 支持括号内的换行。这时有两种情况。</p>
<ol>
<li>第二行缩进到括号的起始处</li>
</ol>
<pre><code class="python">foo = long_function_name(var_one, var_two,
                         var_three, var_four)
</code></pre>
<ol>
<li>第二行缩进 4 个空格，适用于起始括号就换行的情形</li>
</ol>
<pre><code class="python">def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)
</code></pre>
<p>使用反斜杠<code>\</code>换行，二元运算符<code>+</code> <code>.</code>等应出现在行末；长字符串也可以用此法换行</p>
<pre><code class="python">session.query(MyTable).\
        filter_by(id=1).\
        one()

print &#39;Hello, &#39;\
      &#39;%s %s!&#39; %\
      (&#39;Harry&#39;, &#39;Potter&#39;)
</code></pre>
<p>禁止复合语句，即一行中包含多个语句：</p>
<pre><code class="python"># 正确的写法
do_first()
do_second()
do_third()

# 不推荐的写法
do_first();do_second();do_third();
</code></pre>
<p><code>if/for/while</code>一定要换行：</p>
<pre><code class="python"># 正确的写法
if foo == &#39;blah&#39;:
    do_blah_thing()

# 不推荐的写法
if foo == &#39;blah&#39;: do_blash_thing()
</code></pre>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>简单说，自然语言使用双引号，机器标示使用单引号，因此 <strong>代码里</strong> 多数应该使用 <strong>单引号</strong></p>
<ul>
<li><em><strong>自然语言</strong></em> <strong>使用双引号</strong> <code>&quot;...&quot;</code>例如错误信息；很多情况还是 unicode，使用<code>u&quot;你好世界&quot;</code></li>
<li><em><strong>机器标识</strong></em> <strong>使用单引号</strong> <code>&#39;...&#39;</code> 例如 dict 里的 key</li>
<li><em><strong>正则表达式</strong></em> <strong>使用原生的双引号</strong> <code>r&quot;...&quot;</code></li>
<li><em><strong>文档字符串 (docstring)</strong></em> <strong>使用三个双引号</strong> <code>&quot;&quot;&quot;......&quot;&quot;&quot;</code></li>
</ul>
<h2 id="MicroPython（Python3）-基本语法"><a href="#MicroPython（Python3）-基本语法" class="headerlink" title="MicroPython（Python3） 基本语法#"></a><strong>MicroPython（Python3） 基本语法<a target="_blank" rel="noopener" href="https://wiki.sipeed.com/soft/maixpy/zh/get_started/knowledge_micropython.html#MicroPython-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">#</a></strong></h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在 Python 中，等号 <code>=</code> 是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，这种变量本身类型不固定的语言称之为动态语言</p>
<pre><code class="python">a = 123 # a是整数
print(a)
a = &#39;ABC&#39; # a变为字符串
print(a)
</code></pre>
<h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a><strong>list 列表</strong></h3><ul>
<li><strong><code>list</code></strong> 是一种有序的集合, 可以随时添加和删除其中的元素。</li>
</ul>
<pre><code class="python">classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
classmates
[&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
</code></pre>
<ul>
<li>写法类似数组，用索引来访问 list 中每一个位置的元素, 索引是从 0 开始的，记得最后一个元素的索引是 len(classmates) - 1。</li>
<li><code>list</code> 里面的元素的数据类型也可以不同</li>
</ul>
<pre><code class="python">L = [&#39;Apple&#39;, 123, True]
</code></pre>
<h3 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a><strong>tuple 元组</strong></h3><ul>
<li><code>tuple</code>是<code>list</code>的一种，但是 <code>tuple</code> 一旦初始化就不能修改。正因为 <code>tuple</code>不可变, 所以代码更安全。写代码时优先考虑<code>tuple</code>。</li>
</ul>
<pre><code class="python">classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)
</code></pre>
<ul>
<li>定义tuple时注意：定义只有一个元素的tuple时，必须加一个<code>,</code>来消除歧义</li>
</ul>
<pre><code class="python">t = (1, 2)
t
(1, 2)

t = (1,)
t
(1,)
</code></pre>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a><strong>循环</strong></h3><ul>
<li><code>for x in ...</code> 循环：把每个元素代入变量x, 然后执行缩进块的语句.</li>
</ul>
<pre><code class="python">names = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
for name in names:
    print(name)
</code></pre>
<ul>
<li><code>while</code> 循环</li>
</ul>
<pre><code class="python">sum = 0
n = 99
while n &gt; 0:
    sum = sum + n
    n = n - 2
print(sum)
</code></pre>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul>
<li><code>&gt;&gt;&gt; 要转换的类型(转化对象)</code></li>
</ul>
<pre><code class="python">&gt;&gt;&gt; int(&#39;123&#39;)
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float(&#39;12.34&#39;)
12.34
&gt;&gt;&gt; str(1.23)
&#39;1.23&#39;
&gt;&gt;&gt; str(100)
&#39;100&#39;
&gt;&gt;&gt; bool(1)
True
from machine import GPIO
</code></pre>
<pre><code class="c">float f=5.75;
printf(&quot;f=%d,f=%f\n&quot;,(int)f,f);
</code></pre>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><code>def</code>语句：定义函数</li>
</ul>
<pre><code class="python">def power(x, n):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul>
<li>定义：取一个<code>list</code>或<code>tuple</code>的部分元素</li>
<li><code>list</code>的切片</li>
</ul>
<pre><code class="python">L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]

L[0:3]
[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]

L[:3]
[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]

L[1:3]
[&#39;Sarah&#39;, &#39;Tracy&#39;]
</code></pre>
<ul>
<li><code>tuple</code>的切片：切片后的结果还是<code>tuple</code></li>
</ul>
<pre><code class="python">(0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
</code></pre>
<ul>
<li><code>字符串</code> 的切片：’xxx’ 也可以看成是一种 <code>list</code>，每个元素就是一个字符</li>
</ul>
<pre><code class="python">&#39;ABCDEFG&#39;[:3]
&#39;ABC&#39;
</code></pre>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>Python 是面向对象编程的</p>
<pre><code class="python">from pyb import LED

red_led = LED(1)
red_led.on()

#点亮 on, 关掉 off, 查看 value
</code></pre>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul>
<li>在Python 中，一个 <code>.py</code> 文件就称之为一个<strong>模块(Module)</strong>.</li>
<li><code>import</code>语句使用模块：</li>
</ul>
<pre><code class="python">import time

time.sleep_ms(500)
</code></pre>
<h2 id="点亮LED"><a href="#点亮LED" class="headerlink" title="点亮LED"></a>点亮LED</h2><h3 id="FPIOA（现场可编程IO阵列）：外设到引脚的映射"><a href="#FPIOA（现场可编程IO阵列）：外设到引脚的映射" class="headerlink" title="FPIOA（现场可编程IO阵列）：外设到引脚的映射"></a>FPIOA（现场可编程IO阵列）：外设到引脚的映射</h3><p>MaixPy 所使用的硬件 K210 的片上外设对应的引脚（硬件引脚）是可以<strong>任意映射</strong></p>
<pre><code class="python">from fpioa_manager import fm    # 导入库
fm.register(28, fm.fpioa.GPIO0) #将引脚 28 映射为了 GPIO0 的功能
</code></pre>
<p>执行了这句命令后，引脚<code>28</code>和<code>GPIO0</code>就映射（绑定）好了，要取消映射（解绑），则需要调用<code>fm.unregister</code>函数，具体看<code>API</code>文档</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><pre><code class="python">from fpioa_manager import fm                 #导入库
from Maix import GPIO

io_led_red = 13
fm.register(io_led_red, fm.fpioa.GPIO0)      #注册芯片的外设和引脚的对应关系

led_r=GPIO(GPIO.GPIO0, GPIO.OUT)             #定义一个 GPIO 对象led_r
led_r.value(0)                               #设置高低电平
</code></pre>
<h1 id="三、K210外设配置"><a href="#三、K210外设配置" class="headerlink" title="三、K210外设配置"></a>三、K210外设配置</h1><h2 id="sensor"><a href="#sensor" class="headerlink" title="sensor"></a>sensor</h2><pre><code class="python">import sensor, time                                         # 导入感光元件模块 sensor 跟踪运行时间模块 time
</code></pre>
<p>导入模块</p>
<pre><code class="python"># 感光元件设置
sensor.reset()                                              # 重置并初始化感光元件 默认设置为 摄像头频率 24M 不开启双缓冲模式
#sensor.reset(freq=24000000, dual_buff=True)                # 设置摄像头频率 24M 开启双缓冲模式 会提高帧率 但内存占用增加

sensor.set_pixformat(sensor.RGB565)                         # 设置图像格式为 RGB565 (彩色) 除此之外 还可设置格式为 GRAYSCALE 或者 YUV422
sensor.set_framesize(sensor.QVGA)                           # 设置图像大小为 QVGA (320 x 240) 像素个数 76800 K210最大支持格式为 VGA

sensor.set_auto_exposure(1)                                 # 设置自动曝光
#sensor.set_auto_exposure(0, exposure=120000)               # 设置手动曝光 曝光时间 120000 us

sensor.set_auto_gain(0, gain_db = 17)                       # 设置画面增益 17 dB 影响实时画面亮度
sensor.set_auto_whitebal(0, rgb_gain_db = (0,0,0))          # 设置RGB增益 0 0 0 dB 影响画面色彩呈现效果 在 K210 上无法调节增益 初步判定是感光元件 ov2640 无法支持

#sensor.set_contrast(0)                                     # 设置对比度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释
#sensor.set_brightness(0)                                   # 设置亮度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释
#sensor.set_saturation(0)                                   # 设置饱和度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释

sensor.set_vflip(1)                                         # 打开垂直翻转 如果是 01Studio 的 K210 不开启会导致画面方向与运动方向相反
sensor.set_hmirror(1)                                       # 打开水平镜像 如果是 01Studio 的 K210 不开启会导致画面方向与运动方向相反

sensor.skip_frames(time = 2000)                             # 延时跳过2s 等待感光元件稳定
</code></pre>
<p>初始化——格式、大小——曝光（A&#x2F;M）——画面增益、RGB增益——水平翻转、垂直镜像——延时开机</p>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a><strong>image</strong></h2><p><strong>定义一个类来保存颜色属性</strong></p>
<pre><code class="python"># 寻找色块
# 定义类
class color_property():
    cx                      =  0                            # 色块 x轴 中心坐标
    cy                      =  0                            # 色块 y轴 中心坐标
    flag                    =  0                            # 色块标志位 1 找到 0 未找到
    color                   =  0                            # 色块颜色标志位 例如 你可以用 1 来表示 黑色
    density                 =  0                            # 色块密度比 反映色块锁定程度 值越大 锁定程度越好
    pixels_max              =  0                            # 色块像素最大值
    led_flag                =  0                            # LED标志位 方便调试用

    color_threshold         = (0, 0, 0, 0, 0, 0)            # 色块颜色阈值
    color_roi               = (0,0,320,240)                 # 色块寻找区域（感兴趣区域）
    color_x_stride          =  1                            # 色块 x轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    color_y_stride          =  1                            # 色块 y轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    color_pixels_threshold  =  100                          # 色块 像素个数阈值 例如调节此参数为100 则可以滤除色块像素小于100的色块
    color_area_threshold    =  100                          # 色块 被框面积阈值 例如调节此参数为100 则可以滤除色块被框面积小于100的色块
    color_merge             =  True                         # 是否合并寻找到的色块 True 则合并 False 则不合并
    color_margin            =  1                            # 色块合并间距 例如调节此参数为1 若上面选择True合并色块 且被找到的色块有多个 相距1像素 则会将这些色块合并
</code></pre>
<p><strong>实例化颜色属性类</strong></p>
<pre><code class="python"># 实例化类
# 黑色
black = color_property()
black.color_threshold         = (0, 50, -10, 10, -10, 10)  #设置黑色阈值
black.color_roi               = (0,0,320,240)              #设置黑色寻找区域，(x,y,w,h)：即x轴开始坐标，y轴开始坐标，x轴宽度，y轴高度 对于QVGA(0,0,320,240)就是全屏
black.color_x_stride          =  1                         
black.color_y_stride          =  1                         #设置色块x轴、y轴上像素的最小宽度
black.color_pixels_threshold  =  100                       #被找色块像素的个数阈值，被找到的色块像素个数少于这个值，将会被滤除
black.color_area_threshold    =  100                       #设置被找色块被框面积阈值，如果被找到的色块被框面积少于这个值，将会被滤除
black.color_merge             =  True                      #是否需要合并找到的像素，一般需要
black.color_margin            =  1                         #控制色块合并间距

# 红色
red   = color_property()
red.color_threshold           = (0, 100, 20, 127, -5, 127)  #设置红色阈值

#red.color_roi                = (0,0,320,240)
red.color_roi                 = (0,110,320,20)              #设置红色寻找区域

red.color_x_stride            =  1
red.color_y_stride            =  1

#red.color_pixels_threshold   =  100
#red.color_area_threshold     =  100
red.color_pixels_threshold    =  10
red.color_area_threshold      =  10

red.color_merge               =  True
red.color_margin              =  1

# 绿色 预留
green = color_property()

# 蓝色 预留
blue  = color_property()
</code></pre>
<p><strong>定义寻找色块函数</strong></p>
<pre><code class="python"># 定义寻找色块函数
def opv_find_blobs(color,led_flag):
    color.pixels_max = 0                                    # 重置 色块 最大像素数量
    color.flag       = 0                                    # 重置 色块 标志位
    color.led_flag   = 0                                    # 重置 led 标志位

    for blobs in img.find_blobs([color.color_threshold],    # 色块颜色阈值
    roi = color.color_roi,                                  # 色块寻找区域（感兴趣区域）
    x_stride = color.color_x_stride,                        # 色块 x轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    y_stride = color.color_y_stride,                        # 色块 y轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    pixels_threshold = color.color_pixels_threshold,        # 色块 像素个数阈值 例如调节此参数为100 则可以滤除色块像素小于100的色块
    area_threshold = color.color_area_threshold,            # 色块 被框面积阈值 例如调节此参数为100 则可以滤除色块被框面积小于100的色块
    merge = color.color_merge,                              # 是否合并寻找到的色块 True 则合并 False 则不合并
    margin = color.color_margin):                           # 色块合并间距 例如调节此参数为1 若上面选择True合并色块 且被找到的色块有多个 相距1像素 则会将这些色块合并
        img.draw_rectangle(blobs[0:4])                      # 圈出找到的色块
        if color.pixels_max &lt; blobs.pixels():               # 找到面积最大的色块
            color.pixels_max = blobs.pixels()
            color.cx = blobs.cx()                           # 将面积最大的色块的 x轴 中心坐标值 赋值给 color
            color.cy = blobs.cy()                           # 将面积最大的色块的 y轴 中心坐标值 赋值给 color
            color.flag = 1                                  # 标志画面中有找到色块
            color.density = blobs.density()                 # 将面积最大的色块的 色块密度比 赋值给 color
            color.led_flag = led_flag                       # 将控制led颜色的标志位的值 赋值给 color

    if color.flag == 1:                                     # 标记画面中被找到的最大色块的中心坐标
        img.draw_cross(color.cx,color.cy, color=127, size = 15)
        img.draw_circle(color.cx,color.cy, 15, color = 127)
</code></pre>
<p><strong>打印寻找到色块信息</strong></p>
<pre><code class="python"># 定义打印色块参数函数
def print_blobs_property(color,name):
    print(name,&quot;cx:&quot;,color.cx,&quot;cy:&quot;,color.cy,&quot;flag:&quot;,color.flag,&quot;color:&quot;,color.color,&quot;density:&quot;,color.density,&quot;led_flag:&quot;,color.led_flag)
</code></pre>
<p><strong>主函数</strong></p>
<pre><code class="python"># 主函数
while(True):

    clock.tick()                                            # 跟踪运行时间

    img = sensor.snapshot()                                 # 拍摄一张照片
    opv_find_blobs(black,1)                                 # 找黑色色块 led标志为1 表示黑色
    opv_find_blobs(red,2)                                   # 找红色色块 led标志为2 表示红色

    if mycnt == 0:                                          # 如果 mycnt 等于 0 此步骤的目的是控制打印周期 不要打印的太快
        mycnt = 1                                           # 将 1 赋值给 mycnt 使下一次不再满足 mycnt == 0 进入 elif
        print_sensor()                                      # 打印sensor参数
        print_blobs_property(black,&quot;Black-&quot;)                # 打印黑色色块参数
        print_blobs_property(red,  &quot;Red-  &quot;)                # 打印红色色块参数

    elif mycnt &lt; mycnt_max:                                 # 计数变量 小于 计数上限 则 计数变量 自增
        mycnt = mycnt + 1

    else:                                                   # 计数变量 超出 计数上限 则 将0赋值给 mycnt 使下一次进入 if
        mycnt = 0
</code></pre>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><pre><code class="python">from machine import Timer                                   # 从 machine 模块中导入 定时器模块 Timer 

# 定时器的使用
# 定义定时器属性类
class timer_property():
    cnt     = 0                                             # 定时器计数值
    cnt_max = 0                                             # 定时器计数值上限
    period  = 0                                             # 定时器周期
    freq    = 0                                             # 定时器频率
</code></pre>
<p>导入定时器模块，定义一个<strong>类</strong>来保存定时器属性</p>
<pre><code class="python"># 定时器0 配置
# 定时器0 实例化类
timer0 = timer_property()                                   # 实例化定时器属性类 timer_property() 为 timer0
timer0.cnt_max = 9                                          # 设定 定时器0 的计数值上限为 9
timer0.period = 100                                         # 设定 定时器0 的周期为 100
</code></pre>
<p>实例化定时器（0）类</p>
<pre><code class="python"># 定时器0 定义回调函数
def timer0_back(tim0):
    if timer0.cnt &lt; timer0.cnt_max:                         # 若 定时器0 的计数值小于 定时器0 的计数值上限
        timer0.cnt = timer0.cnt + 1                         # 计数值自增
    else:
        timer0.cnt = 0                                      # 超出计数值上限 则计数值重置为0
</code></pre>
<p>定义回调函数（出发定时器中断执行的函数）</p>
<pre><code class="python"># 定时器0 初始化
tim0 = Timer(Timer.TIMER0,                                  # 定时器编号 定时器0
            Timer.CHANNEL0,                                 # 定时器通道 通道0
            mode = Timer.MODE_PERIODIC,                     # 定时器模式 周期性
            unit = Timer.UNIT_MS,                           # 定时器周期单位 ms
            period = timer0.period,                         # 定时器周期 timer0.period 若 unit 为 Timer.UNIT_MS 则周期为 timer0.period ms
            callback = timer0_back)                         # 定时器触发中断后执行的回调函数 timer0_back
</code></pre>
<p>定时器0初始化，定时器模式有一次性、周期性、PWM，一般都是周期性或PWM，一次性使用的很少</p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><pre><code class="python">from machine import Timer, PWM                              # 从 machine 模块中导入 定时器模块 Timer 脉宽调制模块 PWM

# 定时器1 配置
# 电机类定义
class motor_property():
    motor1      = 0                                         # 电机1 占空比
    motor2      = 0                                         # 电机2 占空比
    motor3      = 0                                         # 电机3 占空比
    motor4      = 0                                         # 电机4 占空比

    motor1_pin  = 0                                         # 电机1 引脚
    motor2_pin  = 0                                         # 电机2 引脚
    motor3_pin  = 0                                         # 电机3 引脚
    motor4_pin  = 0                                         # 电机4 引脚

    control_x   = 0                                         # 被控坐标 x
    control_y   = 0                                         # 被控坐标 y
</code></pre>
<p>导入定时器和PWM模块，定义一个类来保存电机属性</p>
<pre><code class="python"># 实例化电机类
motor = motor_property()                                    # 实例化电机类 motor_property() 为 motor
motor.motor1 = 50                                           # 电机1的占空比 初始设置为 50%
motor.motor2 = 50                                           # 电机2的占空比 初始设置为 50%
motor.motor1_pin  = 14                                      # 电机1的引脚 14为红灯引脚 这里先用灯的亮灭观察效果
motor.motor2_pin  = 13                                      # 电机2的引脚 13为绿灯引脚 这里先用灯的亮灭观察效果

# 定时器1 实例化类
timer1 = timer_property()                                   # 实例化定时器属性类 timer_property() 为 timer1
timer1.freq = 1000                                          # 设定 定时器1 的频率为 1000
</code></pre>
<p>实例化电机与定时器（1）类</p>
<pre><code class="python"># 定时器1 通道0 初始化
tim1_ch0 = Timer(Timer.TIMER1,                              # 定时器编号 定时器1
                 Timer.CHANNEL0,                            # 定时器通道 通道0
                 mode = Timer.MODE_PWM)                     # 定时器模式 PWM

# 定时器1 通道1 初始化
tim1_ch1 = Timer(Timer.TIMER1,                              # 定时器编号 定时器1
                 Timer.CHANNEL1,                            # 定时器通道 通道1
                 mode = Timer.MODE_PWM)                     # 定时器模式 PWM
</code></pre>
<p>PWM定时器初始化</p>
<pre><code class="python"># 创建对象 电机1 通道为 定时器1的通道0 频率为 定时器1的频率 占空比为 电机1的占空比 引脚为 电机1的引脚
motor1 = PWM(tim1_ch0, freq = timer1.freq, duty = motor.motor1, pin = motor.motor1_pin)

# 创建对象 电机2 通道为 定时器1的通道1 频率为 定时器1的频率 占空比为 电机2的占空比 引脚为 电机2的引脚
motor2 = PWM(tim1_ch1, freq = timer1.freq, duty = motor.motor2, pin = motor.motor2_pin)
</code></pre>
<p>创建电机对象</p>
<h1 id="四、模块代码"><a href="#四、模块代码" class="headerlink" title="四、模块代码"></a>四、模块代码</h1><h2 id="视觉巡线"><a href="#视觉巡线" class="headerlink" title="视觉巡线"></a>视觉巡线</h2><pre><code class="python">#__________________________________________________________________
# 导入模块
import sensor, time, image                                         # 导入感光元件模块 sensor 跟踪运行时间模块 time
import utime
import lcd
from fpioa_manager import fm
from Maix import GPIO
from machine import Timer, PWM

#__________________________________________________________________
# 配置sensor
sensor.reset()                                              # 重置并初始化感光元件 默认设置为 摄像头频率 24M 不开启双缓冲模式
#sensor.reset(freq=24000000, dual_buff=True)                # 设置摄像头频率 24M 开启双缓冲模式 会提高帧率 但内存占用增加

sensor.set_pixformat(sensor.RGB565)                         # 设置图像格式为 RGB565 (彩色) 除此之外 还可设置格式为 GRAYSCALE 或者 YUV422
sensor.set_framesize(sensor.QVGA)                           # 设置图像大小为 QVGA (320 x 240) 像素个数 76800 K210最大支持格式为 VGA

sensor.set_auto_exposure(1)                                 # 设置自动曝光
#sensor.set_auto_exposure(0, exposure=120000)               # 设置手动曝光 曝光时间 120000 us

sensor.set_auto_gain(0, gain_db = 17)                       # 设置画面增益 17 dB 影响实时画面亮度
sensor.set_auto_whitebal(0, rgb_gain_db = (0,0,0))          # 设置RGB增益 0 0 0 dB 影响画面色彩呈现效果 在 K210 上无法调节增益 初步判定是感光元件 ov2640 无法支持

#sensor.set_contrast(0)                                     # 设置对比度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释
#sensor.set_brightness(0)                                   # 设置亮度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释
#sensor.set_saturation(0)                                   # 设置饱和度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释

sensor.set_vflip(1)                                         # 打开垂直翻转 如果是 01Studio 的 K210 不开启会导致画面方向与运动方向相反
sensor.set_hmirror(1)                                       # 打开水平镜像 如果是 01Studio 的 K210 不开启会导致画面方向与运动方向相反

sensor.skip_frames(time = 2000)                             # 延时跳过2s 等待感光元件稳定

# 打印sensor参数
def print_sensor():
    print(&quot;Expose &quot;+str(sensor.get_exposure_us()))          # 打印 曝光时间
    print(&quot;Gain: &quot;+str(sensor.get_gain_db()))               # 打印 画面增益
    print(&quot;RGB: &quot;+str(sensor.get_rgb_gain_db()))            # 打印 RGB 增益

#__________________________________________________________________
# 配置定时器

# 定义定时器属性类
class timer_property():
    cnt     = 0                                             # 定时器计数值
    cnt_max = 0                                             # 定时器计数值上限
    period  = 0                                             # 定时器周期
    freq    = 0                                             # 定时器频率
#__________________________________________________________________
# 定时器0实例化类
timer0 = timer_property()                                   # 实例化定时器属性类 timer_property() 为 timer0
timer0.cnt_max = 9                                          # 设定 定时器0 的计数值上限为 9
timer0.period = 100                                         # 设定 定时器0 的周期为 100

# 定时器0 定义回调函数
def timer0_back(tim0):
    if timer0.cnt &lt; timer0.cnt_max:                         # 若 定时器0 的计数值小于 定时器0 的计数值上限
        timer0.cnt = timer0.cnt + 1                         # 计数值自增
    else:
        timer0.cnt = 0                                      # 超出计数值上限 则计数值重置为0

# 定时器0 通道0 初始化
tim0 = Timer(Timer.TIMER0,                                  # 定时器编号 定时器0
            Timer.CHANNEL0,                                 # 定时器通道 通道0
            mode = Timer.MODE_PERIODIC,                     # 定时器模式 周期性
            unit = Timer.UNIT_MS,                           # 定时器周期单位 ms
            period = timer0.period,                         # 定时器周期 timer0.period 若 unit 为 Timer.UNIT_MS 则周期为 timer0.period ms
            callback = timer0_back)                         # 定时器触发中断后执行的回调函数 timer0_back
#__________________________________________________________________
# 定时器1实例化类
timer1 = timer_property()                                   # 实例化定时器属性类 timer_property() 为 timer1
timer1.freq = 1000                                          # 设定 定时器1 的频率为 1000

# 定时器1 通道0 初始化
tim1_ch0 = Timer(Timer.TIMER1,                              # 定时器编号 定时器1
                 Timer.CHANNEL0,                            # 定时器通道 通道0
                 mode = Timer.MODE_PWM)                     # 定时器模式 PWM

# 定时器1 通道1 初始化
tim1_ch1 = Timer(Timer.TIMER1,                              # 定时器编号 定时器1
                 Timer.CHANNEL1,                            # 定时器通道 通道1
                 mode = Timer.MODE_PWM)                     # 定时器模式 PWM

#__________________________________________________________________
# 定义目标点输入类
class point_input():
    point1  = 0                                             # 目标点 1
    point2  = 0                                             # 目标点 2
    cross   = 0                                             # 穿圈模式标志位
    send    = 0                                             # 目标点发送标志位

point = point_input()                                       # 实例化目标点输入类 point_input() 为 point

# 按键控制下的目标点获取函数
def point_control(ckey):
    if ckey.control == 1:                                   # 按键确认及发送控制标志位为1 即 按键3 按下
        ckey.control = 0                                    # 重置标志位
        if ckey.cs == 0:                                    # 如果当前为模式 0
            point.send = 1                                  # 目标点发送标志置为 1 串口开始发送

        elif ckey.cs == 1:                                  # 如果当前为模式 1
            point.point1 = ckey.cinput                      # 将按键输入值赋值给目标点 1

        elif ckey.cs == 2:                                  # 如果当前为模式 2
            point.point2 = ckey.cinput                      # 将按键输入值赋值给目标点 2

        elif ckey.cs == 3:                                  # 如果当前为模式 3
            point.cross = ckey.cinput                       # 将按键输入值赋值给 穿圈模式标志位

    if ckey.csflag == 1:                                    # 如果检测到按键模式切换
        ckey.csflag = 0                                     # 重置按键模式切换标志位
        ckey.cinput = 0                                     # 重置按键输入值

#__________________________________________________________________
#按键使用
# 定义按键控制类
class key_control():                                        # 定义按键控制类
    cnt     = 0                                             # 按键计数值
    cs      = 0                                             # 按键模式选择标志位
    csmax   = 0                                             # 按键模式上限
    csflag  = 0                                             # 按键模式切换标志位
    cinput  = 0                                             # 按键输入值保存位
    control = 0                                             # 按键确认及发送控制标志位

# 实例化按键类
key = key_control()                                         # 实例化按键控制类 key_control() 为 key
key.csmax = 4                                               # 按键模式上限为 4 即最多有 4 个模式

# 注册按键引脚
fm.register(16, fm.fpioa.GPIOHS0, force = True)             # 配置 16 脚为 KEY0 使用高速 GPIO 口 强制注册
fm.register(18, fm.fpioa.GPIOHS1, force = True)             # 配置 18 脚为 KEY1 使用高速 GPIO 口 强制注册
fm.register(19, fm.fpioa.GPIOHS2, force = True)             # 配置 19 脚为 KEY2 使用高速 GPIO 口 强制注册
fm.register(20, fm.fpioa.GPIOHS3, force = True)             # 配置 20 脚为 KEY3 使用高速 GPIO 口 强制注册

# 创建按键对象
KEY0 = GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY0
KEY1 = GPIO(GPIO.GPIOHS1, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY1
KEY2 = GPIO(GPIO.GPIOHS2, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY2
KEY3 = GPIO(GPIO.GPIOHS3, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY3

# 中断回调函数 KEY0 控制按键模式选择
def key0_switch(KEY0):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY0.value() == 0:                                   # 确认 按键0 按下
        key.csflag = 1                                      # 标记按键模式切换
        if key.cs &lt; key.csmax:                              # 控制按键模式选择 自增
            key.cs = key.cs + 1
        else:                                               # 若达到上限 则重新从 0 开始
            key.cs = 0

# 中断回调函数 KEY1 按键输入值自增
def key1_switch(KEY1):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY1.value() == 0:                                   # 确认 按键1 按下
        key.cinput = key.cinput + 1                         # 按键输入值自增

# 中断回调函数 KEY2 按键输入值自减
def key2_switch(KEY2):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY2.value() == 0:                                   # 确认 按键2 按下
        key.cinput = key.cinput - 1                         # 按键输入值自减

# 中断回调函数 KEY3 按键确认及发送控制标志位
def key3_switch(KEY3):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY3.value() == 0:                                   # 确认按键按下
        key.control = 1                                     # 按键确认及发送控制标志位

# 开启中断 下降沿触发
KEY0.irq(key0_switch, GPIO.IRQ_FALLING)                     # 开启 按键0 外部中断 下降沿触发
KEY1.irq(key1_switch, GPIO.IRQ_FALLING)                     # 开启 按键1 外部中断 下降沿触发
KEY2.irq(key2_switch, GPIO.IRQ_FALLING)                     # 开启 按键2 外部中断 下降沿触发
KEY3.irq(key3_switch, GPIO.IRQ_FALLING)                     # 开启 按键3 外部中断 下降沿触发

#__________________________________________________________________
# LCD
# LCD 初始化
lcd.init()                                                  # lcd初始化

# LCD 按键信息及目标点信息显示函数
def lcd_key():
    lcd.draw_string(0, 0,  &quot;key_cs: &quot;+str(key.cs), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 15, &quot;cinput: &quot;+str(key.cinput), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 30, &quot;point1: &quot;+str(point.point1), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 45, &quot;point2: &quot;+str(point.point2), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 60, &quot;cross : &quot;+str(point.cross), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 75, &quot;red_cx: &quot;+str(red.cx), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 90, &quot;motor1: &quot;+str(motor.motor1), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 105,&quot;motor2: &quot;+str(motor.motor2), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 120,&quot;FPS   : &quot;+str(clock.fps()), lcd.BLUE, lcd.WHITE)

#__________________________________________________________________
# LED 的使用
# 注册LED引脚
fm.register(13, fm.fpioa.GPIO2, force = True)               # 配置 13 脚为 LED_R 强制注册
fm.register(12, fm.fpioa.GPIO1, force = True)               # 配置 12 脚为 LED_G 强制注册
fm.register(14, fm.fpioa.GPIO0, force = True)               # 配置 14 脚为 LED_B 强制注册

# 创建LED对象
LED_R = GPIO(GPIO.GPIO2, GPIO.OUT)                          # 创建 LED_R 对象
LED_G = GPIO(GPIO.GPIO1, GPIO.OUT)                          # 创建 LED_G 对象
LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)                          # 创建 LED_B 对象

# LED控制函数
def led_control(led_flag):                                  # LED控制函数 根据传入 led_flag 点亮对应的灯
    if led_flag == 0:                                       # 传入参数为 0 所有灯打开
        LED_R.value(0)
        LED_G.value(0)
        LED_B.value(0)

    elif led_flag == 1:                                     # 传入参数为 1 所有灯关闭
        LED_R.value(1)
        LED_G.value(1)
        LED_B.value(1)

    elif led_flag == 2:                                     # 传入参数为 2 红灯常亮
        LED_R.value(0)
        LED_G.value(1)
        LED_B.value(1)

    elif led_flag == 3:                                     # 传入参数为 3 绿灯常亮
        LED_R.value(1)
        LED_G.value(0)
        LED_B.value(1)

    elif led_flag == 4:                                     # 传入参数为 4 蓝灯常亮
        LED_R.value(1)
        LED_G.value(1)
        LED_B.value(0)

    else:                                                   # 其他情况 紫灯
        LED_R.value(0)
        LED_G.value(1)
        LED_B.value(0)

#__________________________________________________________________
# 电机
#定义电机类
class motor_property():
    motor1      = 0                                         # 电机1 占空比
    motor2      = 0                                         # 电机2 占空比
    motor3      = 0                                         # 电机3 占空比
    motor4      = 0                                         # 电机4 占空比

    motor1_pin  = 0                                         # 电机1 引脚
    motor2_pin  = 0                                         # 电机2 引脚
    motor3_pin  = 0                                         # 电机3 引脚
    motor4_pin  = 0                                         # 电机4 引脚

    control_x   = 0                                         # 被控坐标 x
    control_y   = 0                                         # 被控坐标 y

# 实例化电机类
motor = motor_property()                                    # 实例化电机类 motor_property() 为 motor
motor.motor1 = 50                                           # 电机1的占空比 初始设置为 50%
motor.motor2 = 50                                           # 电机2的占空比 初始设置为 50%
motor.motor1_pin  = 14                                      # 电机1的引脚 14为红灯引脚 这里先用灯的亮灭观察效果
motor.motor2_pin  = 13                                      # 电机2的引脚 13为绿灯引脚 这里先用灯的亮灭观察效果

# 创建对象 电机1 通道为 定时器1的通道0 频率为 定时器1的频率 占空比为 电机1的占空比 引脚为 电机1的引脚
motor1 = PWM(tim1_ch0, freq = timer1.freq, duty = motor.motor1, pin = motor.motor1_pin)

# 创建对象 电机2 通道为 定时器1的通道1 频率为 定时器1的频率 占空比为 电机2的占空比 引脚为 电机2的引脚
motor2 = PWM(tim1_ch1, freq = timer1.freq, duty = motor.motor2, pin = motor.motor2_pin)

# 定义电机占空比控制函数
def motor_control(motor, x):
    val = 0
    if x &lt; motor.control_x:                                 # 若 当前坐标 小于 被控坐标x 即当前状态小车在目标的 左边
        val = (motor.control_x - x) * 0.3125                # 获取坐标差值 并转换为 0~50 之间的值
        motor.motor1 = 50 - val                             # 减小 电机1 占空比 电机1为左电机 使小车右转
        motor.motor2 = 50 + val                             # 增大 电机2 占空比 电机2为右电机 使小车右转

    elif x &gt; motor.control_x:                               # 若 当前坐标 大于 被控坐标x 即当前状态小车在目标的 右边
        val = (x - motor.control_x) * 0.3125                # 获取坐标差值 并转换为 0~50 之间的值
        motor.motor1 = 50 + val                             # 增大 电机1 占空比 电机1为左电机 使小车左转
        motor.motor2 = 50 - val                             # 减小 电机2 占空比 电机2为右电机 使小车左转

    motor.motor1 = int(motor.motor1)                        # 将 电机1占空比 转换为 整数
    motor.motor2 = int(motor.motor2)                        # 将 电机1占空比 转换为 整数

#__________________________________________________________________
# 寻找色块

# 定义寻找色块类：
class color_property():
    cx                      =  0                            # 色块 x轴 中心坐标
    cy                      =  0                            # 色块 y轴 中心坐标
    flag                    =  0                            # 色块标志位 1 找到 0 未找到
    color                   =  0                            # 色块颜色标志位 例如 你可以用 1 来表示 黑色
    density                 =  0                            # 色块密度比 反映色块锁定程度 值越大 锁定程度越好
    pixels_max              =  0                            # 色块像素最大值
    led_flag                =  0                            # LED标志位 方便调试用

    color_threshold         = (0, 0, 0, 0, 0, 0)            # 色块颜色阈值
    color_roi               = (0,0,320,240)                 # 色块寻找区域（感兴趣区域）
    color_x_stride          =  1                            # 色块 x轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    color_y_stride          =  1                            # 色块 y轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    color_pixels_threshold  =  100                          # 色块 像素个数阈值 例如调节此参数为100 则可以滤除色块像素小于100的色块
    color_area_threshold    =  100                          # 色块 被框面积阈值 例如调节此参数为100 则可以滤除色块被框面积小于100的色块
    color_merge             =  True                         # 是否合并寻找到的色块 True 则合并 False 则不合并
    color_margin            =  1                            # 色块合并间距 例如调节此参数为1 若上面选择True合并色块 且被找到的色块有多个 相距1像素 则会将这些色块合并

# 实例化寻找色块类：
# 黑色
black = color_property()
black.color_threshold         = (0, 50, -10, 10, -10, 10)  #设置黑色阈值
black.color_roi               = (0,0,320,240)              #设置黑色寻找区域，(x,y,w,h)：即x轴开始坐标，y轴开始坐标，x轴宽度，y轴高度 对于QVGA(0,0,320,240)就是全屏
black.color_x_stride          =  1                         
black.color_y_stride          =  1                         #设置色块x轴、y轴上像素的最小宽度
black.color_pixels_threshold  =  100                       #被找色块像素的个数阈值，被找到的色块像素个数少于这个值，将会被滤除
black.color_area_threshold    =  100                       #设置被找色块被框面积阈值，如果被找到的色块被框面积少于这个值，将会被滤除
black.color_merge             =  True                      #是否需要合并找到的像素，一般需要
black.color_margin            =  1                         #控制色块合并间距

# 红色
red   = color_property()
red.color_threshold           = (0, 100, 20, 127, -5, 127)  #设置红色阈值

#red.color_roi                = (0,0,320,240)
red.color_roi                 = (0,110,320,20)              #设置红色寻找区域

red.color_x_stride            =  1
red.color_y_stride            =  1

#red.color_pixels_threshold   =  100
#red.color_area_threshold     =  100
red.color_pixels_threshold    =  10
red.color_area_threshold      =  10

red.color_merge               =  True
red.color_margin              =  1

# 绿色 预留
green = color_property()

# 蓝色 预留
blue  = color_property()

# 定义寻找色块函数：
def opv_find_blobs(color,led_flag):
    color.pixels_max = 0                                    # 重置 色块 最大像素数量
    color.flag       = 0                                    # 重置 色块 标志位
    color.led_flag   = 0                                    # 重置 led 标志位

    for blobs in img.find_blobs([color.color_threshold],    # 色块颜色阈值
    roi = color.color_roi,                                  # 色块寻找区域（感兴趣区域）
    x_stride = color.color_x_stride,                        # 色块 x轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    y_stride = color.color_y_stride,                        # 色块 y轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    pixels_threshold = color.color_pixels_threshold,        # 色块 像素个数阈值 例如调节此参数为100 则可以滤除色块像素小于100的色块
    area_threshold = color.color_area_threshold,            # 色块 被框面积阈值 例如调节此参数为100 则可以滤除色块被框面积小于100的色块
    merge = color.color_merge,                              # 是否合并寻找到的色块 True 则合并 False 则不合并
    margin = color.color_margin):                           # 色块合并间距 例如调节此参数为1 若上面选择True合并色块 且被找到的色块有多个 相距1像素 则会将这些色块合并
        img.draw_rectangle(blobs[0:4])                      # 圈出找到的色块
        if color.pixels_max &lt; blobs.pixels():               # 找到面积最大的色块
            color.pixels_max = blobs.pixels()
            color.cx = blobs.cx()                           # 将面积最大的色块的 x轴 中心坐标值 赋值给 color
            color.cy = blobs.cy()                           # 将面积最大的色块的 y轴 中心坐标值 赋值给 color
            color.flag = 1                                  # 标志画面中有找到色块
            color.density = blobs.density()                 # 将面积最大的色块的 色块密度比 赋值给 color
            color.led_flag = led_flag                       # 将控制led颜色的标志位的值 赋值给 color

    if color.flag == 1:                                     # 标记画面中被找到的最大色块的中心坐标
        img.draw_cross(color.cx,color.cy, color=127, size = 15)
        img.draw_circle(color.cx,color.cy, 15, color = 127)

# 定义打印色块参数函数
def print_blobs_property(color,name):
    print(name,&quot;cx:&quot;,color.cx,&quot;cy:&quot;,color.cy,&quot;flag:&quot;,color.flag,&quot;color:&quot;,color.color,&quot;density:&quot;,color.density,&quot;led_flag:&quot;,color.led_flag)

#__________________________________________________________________
# 创建时钟对象
clock = time.clock()                                        # 创建时钟对象 clock

#__________________________________________________________________
# 调试区
led_control(1)                                              # 关闭一下所有灯 再进入 while 循环 使显示结果正确

#__________________________________________________________________
# 主函数
while(True):

    clock.tick()                                            # 跟踪运行时间

    img = sensor.snapshot()                                 # 拍摄一张照片

    #opv_find_blobs(black,1)                                # 找黑色色块 led标志为1 表示黑色
    opv_find_blobs(red,2)                                   # 找红色色块 led标志为2 表示红色

    point_control(key)                                      # 按键控制下的目标点获取函数

    lcd.display(img)                                        # LCD 显示图像
    lcd_key()                                               # LCD 显示按键信息及目标点信息

    #led_control(red.led_flag)                              # LED 标记色块识别情况

    motor.control_x = 160                                   # 控制目标处于 x轴中心点 160
    motor_control(motor,red.cx)                             # 电机占空比控制函数获取电机控制占空比

    motor1.duty(motor.motor1)                               # 将获取到的电机1占空比 装载
    motor2.duty(motor.motor2)                               # 将获取到的电机2占空比 装载

    if timer0.cnt == 0:                                     # 如果 timer0.cnt 等于 0 此步骤的目的是控制打印周期 不要打印的太快
        print_sensor()                                      # 打印sensor参数
        print_blobs_property(black,&quot;Black-&quot;)                # 打印黑色色块参数
        print_blobs_property(red,  &quot;Red-  &quot;)                # 打印红色色块参数
</code></pre>
<h2 id="数字识别"><a href="#数字识别" class="headerlink" title="数字识别"></a>数字识别</h2><pre><code class="python">
</code></pre>
<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><p><strong>框架：</strong></p>
<table>
<thead>
<tr>
<th>帧头1</th>
<th>帧头2</th>
<th>有效长度位</th>
<th>data[0]</th>
<th>data[1]</th>
<th>……</th>
<th>data[n]</th>
<th>校验位</th>
</tr>
</thead>
</table>
<p>用两个帧头是为了防止帧头和数据混在一起，只有当检测到两个帧头时，才开始接收数据</p>
<p><strong>K210部分</strong></p>
<pre><code class="python">#__________________________________________________________________
# 导入模块
import sensor, time, image                                         # 导入感光元件模块 sensor 跟踪运行时间模块 time
import utime
import lcd
from fpioa_manager import fm
from Maix import GPIO
from machine import Timer, PWM

#__________________________________________________________________
# 配置sensor
sensor.reset()                                              # 重置并初始化感光元件 默认设置为 摄像头频率 24M 不开启双缓冲模式
#sensor.reset(freq=24000000, dual_buff=True)                # 设置摄像头频率 24M 开启双缓冲模式 会提高帧率 但内存占用增加

sensor.set_pixformat(sensor.RGB565)                         # 设置图像格式为 RGB565 (彩色) 除此之外 还可设置格式为 GRAYSCALE 或者 YUV422
sensor.set_framesize(sensor.QVGA)                           # 设置图像大小为 QVGA (320 x 240) 像素个数 76800 K210最大支持格式为 VGA

sensor.set_auto_exposure(1)                                 # 设置自动曝光
#sensor.set_auto_exposure(0, exposure=120000)               # 设置手动曝光 曝光时间 120000 us

sensor.set_auto_gain(0, gain_db = 17)                       # 设置画面增益 17 dB 影响实时画面亮度
sensor.set_auto_whitebal(0, rgb_gain_db = (0,0,0))          # 设置RGB增益 0 0 0 dB 影响画面色彩呈现效果 在 K210 上无法调节增益 初步判定是感光元件 ov2640 无法支持

#sensor.set_contrast(0)                                     # 设置对比度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释
#sensor.set_brightness(0)                                   # 设置亮度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释
#sensor.set_saturation(0)                                   # 设置饱和度 0 这个参数无法读取 且调这个参数对画面似乎不会产生影响 暂时注释

sensor.set_vflip(1)                                         # 打开垂直翻转 如果是 01Studio 的 K210 不开启会导致画面方向与运动方向相反
sensor.set_hmirror(1)                                       # 打开水平镜像 如果是 01Studio 的 K210 不开启会导致画面方向与运动方向相反

sensor.skip_frames(time = 2000)                             # 延时跳过2s 等待感光元件稳定

#__________________________________________________________________
# 配置定时器

# 定义定时器属性类
class timer_property():
    cnt     = 0                                             # 定时器计数值
    cnt_max = 0                                             # 定时器计数值上限
    period  = 0                                             # 定时器周期
    freq    = 0                                             # 定时器频率
#__________________________________________________________________
# 定时器0实例化类
timer0 = timer_property()                                   # 实例化定时器属性类 timer_property() 为 timer0
timer0.cnt_max = 9                                          # 设定 定时器0 的计数值上限为 9
timer0.period = 100                                         # 设定 定时器0 的周期为 100

# 定时器0 定义回调函数
def timer0_back(tim0):
    if timer0.cnt &lt; timer0.cnt_max:                         # 若 定时器0 的计数值小于 定时器0 的计数值上限
        timer0.cnt = timer0.cnt + 1                         # 计数值自增
    else:
        timer0.cnt = 0                                      # 超出计数值上限 则计数值重置为0

# 定时器0 通道0 初始化
tim0 = Timer(Timer.TIMER0,                                  # 定时器编号 定时器0
            Timer.CHANNEL0,                                 # 定时器通道 通道0
            mode = Timer.MODE_PERIODIC,                     # 定时器模式 周期性
            unit = Timer.UNIT_MS,                           # 定时器周期单位 ms
            period = timer0.period,                         # 定时器周期 timer0.period 若 unit 为 Timer.UNIT_MS 则周期为 timer0.period ms
            callback = timer0_back)                         # 定时器触发中断后执行的回调函数 timer0_back
#__________________________________________________________________
# 定时器1实例化类
timer1 = timer_property()                                   # 实例化定时器属性类 timer_property() 为 timer1
timer1.freq = 1000                                          # 设定 定时器1 的频率为 1000

# 定时器1 通道0 初始化
tim1_ch0 = Timer(Timer.TIMER1,                              # 定时器编号 定时器1
                 Timer.CHANNEL0,                            # 定时器通道 通道0
                 mode = Timer.MODE_PWM)                     # 定时器模式 PWM

# 定时器1 通道1 初始化
tim1_ch1 = Timer(Timer.TIMER1,                              # 定时器编号 定时器1
                 Timer.CHANNEL1,                            # 定时器通道 通道1
                 mode = Timer.MODE_PWM)                     # 定时器模式 PWM

#__________________________________________________________________
# 定义目标点输入类
class point_input():
    point1  = 0                                             # 目标点 1
    point2  = 0                                             # 目标点 2
    cross   = 0                                             # 穿圈模式标志位
    send    = 0                                             # 目标点发送标志位

point = point_input()                                       # 实例化目标点输入类 point_input() 为 point

# 按键控制下的目标点获取函数
def point_control(ckey):
    if ckey.control == 1:                                   # 按键确认及发送控制标志位为1 即 按键3 按下
        ckey.control = 0                                    # 重置标志位
        if ckey.cs == 0:                                    # 如果当前为模式 0
            point.send = 1                                  # 目标点发送标志置为 1 串口开始发送

        elif ckey.cs == 1:                                  # 如果当前为模式 1
            point.point1 = ckey.cinput                      # 将按键输入值赋值给目标点 1

        elif ckey.cs == 2:                                  # 如果当前为模式 2
            point.point2 = ckey.cinput                      # 将按键输入值赋值给目标点 2

        elif ckey.cs == 3:                                  # 如果当前为模式 3
            point.cross = ckey.cinput                       # 将按键输入值赋值给 穿圈模式标志位

    if ckey.csflag == 1:                                    # 如果检测到按键模式切换
        ckey.csflag = 0                                     # 重置按键模式切换标志位
        ckey.cinput = 0                                     # 重置按键输入值

#__________________________________________________________________
#按键使用
# 定义按键控制类
class key_control():                                        # 定义按键控制类
    cnt     = 0                                             # 按键计数值
    cs      = 0                                             # 按键模式选择标志位
    csmax   = 0                                             # 按键模式上限
    csflag  = 0                                             # 按键模式切换标志位
    cinput  = 0                                             # 按键输入值保存位
    control = 0                                             # 按键确认及发送控制标志位

# 实例化按键类
key = key_control()                                         # 实例化按键控制类 key_control() 为 key
key.csmax = 4                                               # 按键模式上限为 4 即最多有 4 个模式

# 注册按键引脚
fm.register(16, fm.fpioa.GPIOHS0, force = True)             # 配置 16 脚为 KEY0 使用高速 GPIO 口 强制注册
fm.register(18, fm.fpioa.GPIOHS1, force = True)             # 配置 18 脚为 KEY1 使用高速 GPIO 口 强制注册
fm.register(19, fm.fpioa.GPIOHS2, force = True)             # 配置 19 脚为 KEY2 使用高速 GPIO 口 强制注册
fm.register(20, fm.fpioa.GPIOHS3, force = True)             # 配置 20 脚为 KEY3 使用高速 GPIO 口 强制注册

# 创建按键对象
KEY0 = GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY0
KEY1 = GPIO(GPIO.GPIOHS1, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY1
KEY2 = GPIO(GPIO.GPIOHS2, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY2
KEY3 = GPIO(GPIO.GPIOHS3, GPIO.IN, GPIO.PULL_UP)            # 创建按键对象 KEY3

# 中断回调函数 KEY0 控制按键模式选择
def key0_switch(KEY0):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY0.value() == 0:                                   # 确认 按键0 按下
        key.csflag = 1                                      # 标记按键模式切换
        if key.cs &lt; key.csmax:                              # 控制按键模式选择 自增
            key.cs = key.cs + 1
        else:                                               # 若达到上限 则重新从 0 开始
            key.cs = 0

# 中断回调函数 KEY1 按键输入值自增
def key1_switch(KEY1):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY1.value() == 0:                                   # 确认 按键1 按下
        key.cinput = key.cinput + 1                         # 按键输入值自增

# 中断回调函数 KEY2 按键输入值自减
def key2_switch(KEY2):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY2.value() == 0:                                   # 确认 按键2 按下
        key.cinput = key.cinput - 1                         # 按键输入值自减

# 中断回调函数 KEY3 按键确认及发送控制标志位
def key3_switch(KEY3):
    utime.sleep_ms(10)                                      # 延时 10ms 消除按键抖动
    if KEY3.value() == 0:                                   # 确认按键按下
        key.control = 1                                     # 按键确认及发送控制标志位

# 开启中断 下降沿触发
KEY0.irq(key0_switch, GPIO.IRQ_FALLING)                     # 开启 按键0 外部中断 下降沿触发
KEY1.irq(key1_switch, GPIO.IRQ_FALLING)                     # 开启 按键1 外部中断 下降沿触发
KEY2.irq(key2_switch, GPIO.IRQ_FALLING)                     # 开启 按键2 外部中断 下降沿触发
KEY3.irq(key3_switch, GPIO.IRQ_FALLING)                     # 开启 按键3 外部中断 下降沿触发

#__________________________________________________________________
# LCD
# LCD 初始化
lcd.init()                                                  # lcd初始化

# LCD 按键信息及目标点信息显示函数
def lcd_key():
    lcd.draw_string(0, 0,  &quot;key_cs: &quot;+str(key.cs), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 15, &quot;cinput: &quot;+str(key.cinput), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 30, &quot;point1: &quot;+str(point.point1), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 45, &quot;point2: &quot;+str(point.point2), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 60, &quot;cross : &quot;+str(point.cross), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 75, &quot;red_cx: &quot;+str(red.cx), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 90, &quot;motor1: &quot;+str(motor.motor1), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 105,&quot;motor2: &quot;+str(motor.motor2), lcd.BLUE, lcd.WHITE)
    lcd.draw_string(0, 120,&quot;FPS   : &quot;+str(clock.fps()), lcd.BLUE, lcd.WHITE)

#__________________________________________________________________
# LED 的使用
# 注册LED引脚
fm.register(13, fm.fpioa.GPIO2, force = True)               # 配置 13 脚为 LED_R 强制注册
fm.register(12, fm.fpioa.GPIO1, force = True)               # 配置 12 脚为 LED_G 强制注册
fm.register(14, fm.fpioa.GPIO0, force = True)               # 配置 14 脚为 LED_B 强制注册

# 创建LED对象
LED_R = GPIO(GPIO.GPIO2, GPIO.OUT)                          # 创建 LED_R 对象
LED_G = GPIO(GPIO.GPIO1, GPIO.OUT)                          # 创建 LED_G 对象
LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)                          # 创建 LED_B 对象

# LED控制函数
def led_control(led_flag):                                  # LED控制函数 根据传入 led_flag 点亮对应的灯
    if led_flag == 0:                                       # 传入参数为 0 所有灯打开
        LED_R.value(0)
        LED_G.value(0)
        LED_B.value(0)

    elif led_flag == 1:                                     # 传入参数为 1 所有灯关闭
        LED_R.value(1)
        LED_G.value(1)
        LED_B.value(1)

    elif led_flag == 2:                                     # 传入参数为 2 红灯常亮
        LED_R.value(0)
        LED_G.value(1)
        LED_B.value(1)

    elif led_flag == 3:                                     # 传入参数为 3 绿灯常亮
        LED_R.value(1)
        LED_G.value(0)
        LED_B.value(1)

    elif led_flag == 4:                                     # 传入参数为 4 蓝灯常亮
        LED_R.value(1)
        LED_G.value(1)
        LED_B.value(0)

    else:                                                   # 其他情况 紫灯
        LED_R.value(0)
        LED_G.value(1)
        LED_B.value(0)

#__________________________________________________________________
# 电机
#定义电机类
class motor_property():
    motor1      = 0                                         # 电机1 占空比
    motor2      = 0                                         # 电机2 占空比
    motor3      = 0                                         # 电机3 占空比
    motor4      = 0                                         # 电机4 占空比

    motor1_pin  = 0                                         # 电机1 引脚
    motor2_pin  = 0                                         # 电机2 引脚
    motor3_pin  = 0                                         # 电机3 引脚
    motor4_pin  = 0                                         # 电机4 引脚

    control_x   = 0                                         # 被控坐标 x
    control_y   = 0                                         # 被控坐标 y

# 实例化电机类
motor = motor_property()                                    # 实例化电机类 motor_property() 为 motor
motor.motor1 = 50                                           # 电机1的占空比 初始设置为 50%
motor.motor2 = 50                                           # 电机2的占空比 初始设置为 50%
motor.motor1_pin  = 14                                      # 电机1的引脚 14为红灯引脚 这里先用灯的亮灭观察效果
motor.motor2_pin  = 13                                      # 电机2的引脚 13为绿灯引脚 这里先用灯的亮灭观察效果

# 创建对象 电机1 通道为 定时器1的通道0 频率为 定时器1的频率 占空比为 电机1的占空比 引脚为 电机1的引脚
motor1 = PWM(tim1_ch0, freq = timer1.freq, duty = motor.motor1, pin = motor.motor1_pin)

# 创建对象 电机2 通道为 定时器1的通道1 频率为 定时器1的频率 占空比为 电机2的占空比 引脚为 电机2的引脚
motor2 = PWM(tim1_ch1, freq = timer1.freq, duty = motor.motor2, pin = motor.motor2_pin)

# 定义电机占空比控制函数
def motor_control(motor, x):
    val = 0
    if x &lt; motor.control_x:                                 # 若 当前坐标 小于 被控坐标x 即当前状态小车在目标的 左边
        val = (motor.control_x - x) * 0.3125                # 获取坐标差值 并转换为 0~50 之间的值
        motor.motor1 = 50 - val                             # 减小 电机1 占空比 电机1为左电机 使小车右转
        motor.motor2 = 50 + val                             # 增大 电机2 占空比 电机2为右电机 使小车右转

    elif x &gt; motor.control_x:                               # 若 当前坐标 大于 被控坐标x 即当前状态小车在目标的 右边
        val = (x - motor.control_x) * 0.3125                # 获取坐标差值 并转换为 0~50 之间的值
        motor.motor1 = 50 + val                             # 增大 电机1 占空比 电机1为左电机 使小车左转
        motor.motor2 = 50 - val                             # 减小 电机2 占空比 电机2为右电机 使小车左转

    motor.motor1 = int(motor.motor1)                        # 将 电机1占空比 转换为 整数
    motor.motor2 = int(motor.motor2)                        # 将 电机1占空比 转换为 整数

#__________________________________________________________________
# 串口的使用
# 串口1 设置 P6 RX P7 TX
fm.register(6, fm.fpioa.UART1_RX, force = True)             # 配置 6 脚为 UART1_RX 强制注册
fm.register(7, fm.fpioa.UART1_TX, force = True)             # 配置 7 脚为 UART1_TX 强制注册

uart1 = UART(UART.UART1, 115200, 8, 0, 1)                   # 设置 uart1 为 串口1 波特率 921600 数据位 8位 校验位 0位 停止位 1位

# 串口2 设置 P9 RX P10 TX
fm.register(9, fm.fpioa.UART2_RX, force = True)             # 配置 9 脚为 UART2_RX 强制注册
fm.register(10, fm.fpioa.UART2_TX, force = True)            # 配置 10 脚为 UART2_TX 强制注册

uart2 = UART(UART.UART2, 921600, 8, 0, 1)                   # 设置 uart2 为 串口2 波特率 921600 数据位 8位 校验位 0位 停止位 1位

#__________________________________________________________________
# 串口发送
# 定义 UART 发送类
class UART_Transmit():                                      # 定义 UART 发送类
    pack_flag   = 0                                         # 打包方法标志位
    head1  = 0x00                                           # uint8_t   帧头1
    head2  = 0x00                                           # uint8_t   帧头2
    x      = 0                                              # uint16_t  目标x轴坐标
    y      = 0                                              # uint16_t  目标y轴坐标
    color  = 0                                              # uint8_t   目标颜色标志位
    shape  = 0                                              # uint8_t   目标形状标志位
    flag   = 0                                              # uint8_t   目标标志位
    mode   = 0                                              # uint8_t   模式标志位

# 实例化类
TSTM32  = UART_Transmit()                                   # 实例化 UART_Transmit() 为 TSTM32
TSTM32.pack_flag  = 1                                       # 打包方法为 方法1
TSTM32.head1 = 0xAA                                         # TSTM32 的帧头1为 0xAA
TSTM32.head2 = 0xAA                                         # TSTM32 的帧头2为 0xAA

TOpenMV = UART_Transmit()                                   # 实例化 UART_Transmit() 为 TOpenMV
TOpenMV.pack_flag  = 2                                      # 打包方法为 方法2
TOpenMV.head1 = 0xAA                                        # TOpenMV 的帧头1为 0xAA
TOpenMV.head2 = 0xAA                                        # TOpenMV 的帧头2为 0xAA

# 定义打包函数
def Pack_Data(TData):

    data = UART_Pack_Method(TData)                          # 根据不同的方法打包发送数据

    # 数据包的长度
    data_len = len(data)                                    # 获得数据包总长度
    data[2]  = data_len - 4                                 # 有效数据的长度 扣去 帧头1 帧头2 有效数据长度位 校验位

    # 校验和
    sum = 0                                                 # 和置零
    for i in range(0,data_len-1):
        sum = sum + data[i]                                 # 和累加
    data[data_len-1] = sum                                  # 和赋值 给数组最后一位发送 只保存低8位 溢出部分无效

    # 返回打包好的数据
    return data

#__________________________________________________________________
# 串口接收
# 定义 UART 接收类
class UART_Receive(object):                                 # 定义 UART 接收类
    uart_buf  = []                                          # 串口缓冲区数组
    data_len  = 0                                           # 有效数据长度
    data_cnt  = 0                                           # 总数据长度
    state     = 0                                           # 接收状态
    buf_len   = 0                                           # 保存串口等待字节的数量

    head1     = 0x00                                        # 接收帧头1
    head2     = 0x00                                        # 接收帧头2
    lenmax    = 0                                           # 有效数据最大长度
    save_flag = 0                                           # 保存方法标志位

# 实例化类
RSTM32  = UART_Receive()                                    # 实例化 UART_Receive() 为 RSTM32
RSTM32.head1        = 0xAA                                  # RSTM32 的帧头1为 0xAA
RSTM32.head2        = 0xAA                                  # RSTM32 的帧头2为 0xAA
RSTM32.lenmax       = 40                                    # RSTM32 的有效数据最大长度为 40
RSTM32.save_flag    = 1                                     # RSTM32 的保存方法标志位为 1

ROpenMV = UART_Receive()                                    # 实例化 UART_Receive() 为 ROpenMV
ROpenMV.head1       = 0xAA                                  # ROpenMV 的帧头1为 0xAA
ROpenMV.head2       = 0xAA                                  # ROpenMV 的帧头2为 0xAA
ROpenMV.lenmax      = 40                                    # ROpenMV 的有效数据最大长度为 40
ROpenMV.save_flag   = 2                                     # ROpenMV 的保存方法标志位为 2

# 定义串口数据读取函数
def UART_Read(RData, uart):
    RData.buf_len = uart.any()                              # 检查 串口 是否有内容需要读取 返回等待的字节数量（可能为0）
    for i in range(0, RData.buf_len):                       # 读取 RData.buf_len 个数据
        Receive_Data(RData, uart.readchar())                # 接收单个数据 uart.readchar() 然后将这个数据传递到函数 Receive_Data() 进行 数据接收

# 定义串口数据接收函数
def Receive_Data(RData, buf):
    if RData.state == 0 and buf == RData.head1:             # 判断帧头1是否符合要求 符合则进入下一个状态
        RData.state = 1                                     # 更改状态为 1
        RData.uart_buf.append(buf)                          # 将这个数据添加到数组末尾

    elif RData.state == 1 and buf == RData.head2:           # 判断帧头2是否符合要求 符合则进入下一个状态
        RData.state = 2                                     # 更改状态为 2
        RData.uart_buf.append(buf)                          # 将这个数据添加到数组末尾

    elif RData.state == 2 and buf &lt; RData.lenmax:           # 有效数据长度位 规定有效数据长度小于40 符合则进入下一个状态
        RData.state = 3                                     # 更改状态为 3
        RData.data_len = buf                                # 获得有效数据长度
        RData.data_cnt = buf + 4                            # 获得总数据长度 总数据长度 = 帧头1 + 帧头2 + 有效数据长度位 + 有效数据 + 校验位
        RData.uart_buf.append(buf)                          # 将这个数据添加到数组末尾

    elif RData.state == 3 and RData.data_len &gt; 0:           # 存储有效数据长度个数据
        RData.data_len = RData.data_len - 1                 # 每存储一次 还需要存储的数据个数减1
        RData.uart_buf.append(buf)                          # 将这个数据添加到数组末尾
        if RData.data_len == 0:                             # 直到存储完毕
            RData.state = 4                                 # 进入下一个状态

    elif RData.state == 4:                                  # 当接收到存储完毕的信息
        RData.uart_buf.append(buf)                          # 保存最后一位校验位 将这个数据添加到数组末尾
        RData.state = 0                                     # 状态重置为0 调用串口数据解析函数进行数据解析
        Parse_Data(RData)                                   # 解析数据
        #print(RData.uart_buf)                              # 打印接收数组 若接收结果不对 可取消注释查看数组
        RData.uart_buf = []                                 # 清空缓冲区 准备下次接收数据

    else:                                                   # 不满足以上条件 视为接收出错 重置状态为0 丢弃所有数据 准备下一次接收数据
        RData.state = 0                                     # 重置状态为0
        RData.uart_buf = []                                 # 清空缓冲区 准备下一次接收数据

# 定义串口数据解析函数
def Parse_Data(PData):
    # 和累加
    sum = 0                                                 # 和置0
    i = 0                                                   # 已循环次数置0
    while i &lt; (PData.data_cnt - 1):                         # 循环累加
        sum = sum + PData.uart_buf[i]                       # 累加求数组和
        i = i + 1                                           # 已循环次数自增
    # 求余 因为 校验和 为 8 位 超出部分无效 因此只校验 低8位 即可
    sum = sum % 256                                         # 和对256取余 得低八位

    # 和校验失败则退出
    if sum != PData.uart_buf[PData.data_cnt - 1]:           # 和取余结果若不等于校验位的值
        return                                              # 退出

    # 和校验成功则根据保存方法的不同 接收数据
    UART_Save_Method(PData)

#__________________________________________________________________
# 寻找色块

# 定义寻找色块类：
class color_property():
    cx                      =  0                            # 色块 x轴 中心坐标
    cy                      =  0                            # 色块 y轴 中心坐标
    flag                    =  0                            # 色块标志位 1 找到 0 未找到
    color                   =  0                            # 色块颜色标志位 例如 你可以用 1 来表示 黑色
    density                 =  0                            # 色块密度比 反映色块锁定程度 值越大 锁定程度越好
    pixels_max              =  0                            # 色块像素最大值
    led_flag                =  0                            # LED标志位 方便调试用

    color_threshold         = (0, 0, 0, 0, 0, 0)            # 色块颜色阈值
    color_roi               = (0,0,320,240)                 # 色块寻找区域（感兴趣区域）
    color_x_stride          =  1                            # 色块 x轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    color_y_stride          =  1                            # 色块 y轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    color_pixels_threshold  =  100                          # 色块 像素个数阈值 例如调节此参数为100 则可以滤除色块像素小于100的色块
    color_area_threshold    =  100                          # 色块 被框面积阈值 例如调节此参数为100 则可以滤除色块被框面积小于100的色块
    color_merge             =  True                         # 是否合并寻找到的色块 True 则合并 False 则不合并
    color_margin            =  1                            # 色块合并间距 例如调节此参数为1 若上面选择True合并色块 且被找到的色块有多个 相距1像素 则会将这些色块合并

# 实例化寻找色块类：
# 黑色
black = color_property()
black.color_threshold         = (0, 50, -10, 10, -10, 10)  #设置黑色阈值
black.color_roi               = (0,0,320,240)              #设置黑色寻找区域，(x,y,w,h)：即x轴开始坐标，y轴开始坐标，x轴宽度，y轴高度 对于QVGA(0,0,320,240)就是全屏
black.color_x_stride          =  1                         
black.color_y_stride          =  1                         #设置色块x轴、y轴上像素的最小宽度
black.color_pixels_threshold  =  100                       #被找色块像素的个数阈值，被找到的色块像素个数少于这个值，将会被滤除
black.color_area_threshold    =  100                       #设置被找色块被框面积阈值，如果被找到的色块被框面积少于这个值，将会被滤除
black.color_merge             =  True                      #是否需要合并找到的像素，一般需要
black.color_margin            =  1                         #控制色块合并间距

# 红色
red   = color_property()
red.color_threshold           = (0, 100, 20, 127, -5, 127)  #设置红色阈值

#red.color_roi                = (0,0,320,240)
red.color_roi                 = (0,110,320,20)              #设置红色寻找区域

red.color_x_stride            =  1
red.color_y_stride            =  1

#red.color_pixels_threshold   =  100
#red.color_area_threshold     =  100
red.color_pixels_threshold    =  10
red.color_area_threshold      =  10

red.color_merge               =  True
red.color_margin              =  1

# 绿色 预留
green = color_property()

# 蓝色 预留
blue  = color_property()

# 定义寻找色块函数：
def opv_find_blobs(color,led_flag):
    color.pixels_max = 0                                    # 重置 色块 最大像素数量
    color.flag       = 0                                    # 重置 色块 标志位
    color.led_flag   = 0                                    # 重置 led 标志位

    for blobs in img.find_blobs([color.color_threshold],    # 色块颜色阈值
    roi = color.color_roi,                                  # 色块寻找区域（感兴趣区域）
    x_stride = color.color_x_stride,                        # 色块 x轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    y_stride = color.color_y_stride,                        # 色块 y轴 像素最小宽度 色块如果比较大可以调大此参数 提高寻找速度
    pixels_threshold = color.color_pixels_threshold,        # 色块 像素个数阈值 例如调节此参数为100 则可以滤除色块像素小于100的色块
    area_threshold = color.color_area_threshold,            # 色块 被框面积阈值 例如调节此参数为100 则可以滤除色块被框面积小于100的色块
    merge = color.color_merge,                              # 是否合并寻找到的色块 True 则合并 False 则不合并
    margin = color.color_margin):                           # 色块合并间距 例如调节此参数为1 若上面选择True合并色块 且被找到的色块有多个 相距1像素 则会将这些色块合并
        img.draw_rectangle(blobs[0:4])                      # 圈出找到的色块
        if color.pixels_max &lt; blobs.pixels():               # 找到面积最大的色块
            color.pixels_max = blobs.pixels()
            color.cx = blobs.cx()                           # 将面积最大的色块的 x轴 中心坐标值 赋值给 color
            color.cy = blobs.cy()                           # 将面积最大的色块的 y轴 中心坐标值 赋值给 color
            color.flag = 1                                  # 标志画面中有找到色块
            color.density = blobs.density()                 # 将面积最大的色块的 色块密度比 赋值给 color
            color.led_flag = led_flag                       # 将控制led颜色的标志位的值 赋值给 color

    if color.flag == 1:                                     # 标记画面中被找到的最大色块的中心坐标
        img.draw_cross(color.cx,color.cy, color=127, size = 15)
        img.draw_circle(color.cx,color.cy, 15, color = 127)

#__________________________________________________________________
# 创建时钟对象
clock = time.clock()                                        # 创建时钟对象 clock

#__________________________________________________________________
# 调试区
# 定义 K210 属性类
class K210_Property(object):                                # 定义 K210 接收类
    x      = 0                                              # uint16_t  目标x轴坐标
    y      = 0                                              # uint16_t  目标y轴坐标
    color  = 0                                              # uint8_t   目标颜色标志位
    shape  = 0                                              # uint8_t   目标形状标志位
    flag   = 0                                              # uint8_t   目标标志位
    mode   = 0                                              # uint8_t   工作模式位

# 实例化类
K210 = K210_Property()                                      # 实例化 K210_Property() 为 K210

LED_Control(1)                                              # 关闭一下所有灯 再进入 while 循环 使显示结果正确

# 串口发送测试信息赋值
TSTM32.mode   = 1

TOpenMV.x     = 65535
TOpenMV.y     = 65536
TOpenMV.color = 255
TOpenMV.shape = 256
TOpenMV.flag  = 3

# 打印信息函数
# 打印 sensor 各参数
def Print_sensor():
    print(&quot;Exposure :&quot;, sensor.get_exposure_us(), &quot;Gain:&quot;, sensor.get_gain_db(), &quot;RGB:&quot;, sensor.get_rgb_gain_db())

# 打印 K210 各参数
def Print_K210():
    print(&quot;Mode:&quot;, K210.mode, &quot;x:&quot;, K210.x, &quot;y:&quot;, K210.y, &quot;color:&quot;, K210.color, &quot;shape:&quot;, K210.shape, &quot;flag:&quot;, K210.flag)

# 打印 色块 各参数
def Print_Blobs_Property(color,name):
    print(name,&quot;cx:&quot;,color.cx,&quot;cy:&quot;,color.cy,&quot;flag:&quot;,color.flag,&quot;color:&quot;,color.color,&quot;density:&quot;,color.density,&quot;led_flag:&quot;,color.led_flag)

# 打印总函数
def Print_All():
    print(&quot;______________________________________________________________________&quot;)
    Print_sensor()                                          # 打印 sensor 参数
    Print_Blobs_Property(black,&quot;Black &quot;)                    # 打印 黑色色块 参数
    Print_Blobs_Property(red,  &quot;Red   &quot;)                    # 打印 红色色块 参数
    Print_K210()                                            # 打印 K210 参数

# 串口数据打包方法函数
def UART_Pack_Method(TData):
    if TData.pack_flag == 1:
        data = bytearray([TData.head1,                      # 帧头1
                          TData.head2,                      # 帧头2
                          0x00,                             # 有效数据长度 0x00 + data_len - 4
                          TData.mode,                       # 保存目标x轴坐标 高八位
                          0x00])                            # 数据和校验位

    elif TData.pack_flag == 2:
        data = bytearray([TData.head1,                      # 帧头1
                          TData.head2,                      # 帧头2
                          0x00,                             # 有效数据长度 0x00 + data_len - 4
                          TData.x&gt;&gt;8,                       # 保存目标x轴坐标 高八位
                          TData.x,                          # 保存目标x轴坐标 低八位
                          TData.y&gt;&gt;8,                       # 保存目标y轴坐标 高八位
                          TData.y,                          # 保存目标y轴坐标 低八位
                          TData.color,                      # 保存目标颜色标志位
                          TData.shape,                      # 保存目标形状标志位
                          TData.flag,                       # 保存目标标志位
                          0x00])                            # 数据和校验位

    return data

# 串口数据保存方法函数
def UART_Save_Method(PData):
    if PData.save_flag == 1 and PData.uart_buf[2] &gt; 0:
        K210.mode =  PData.uart_buf[3]

    elif PData.save_flag == 2 and PData.uart_buf[2] &gt; 6:
        K210.x      = PData.uart_buf[3]*256 + PData.uart_buf[4]
        K210.y      = PData.uart_buf[5]*256 + PData.uart_buf[6]
        K210.color  = PData.uart_buf[7]
        K210.shape  = PData.uart_buf[8]
        K210.flag   = PData.uart_buf[9]

#__________________________________________________________________
# 主函数
while(True):

    clock.tick()                                            # 跟踪运行时间

   # 模式选择______________________________________________________

    if K210.mode == 0x00:
        img=sensor.snapshot()                               # 拍摄一张照片

    elif K210.mode == 0x01:
        img=sensor.snapshot()                               # 拍摄一张照片
        K210_Find_Blobs(black,1)                            # 找黑色色块 LED标志为1 表示黑色
        motor.control_x = 160                               # 控制目标处于 x轴中心点 160
        Motor_Control(motor,black.cx)                       # 电机占空比控制函数获取电机控制占空比
        motor1.duty(motor.motor1)                           # 将获取到的电机1占空比 装载
        motor2.duty(motor.motor2)                           # 将获取到的电机2占空比 装载

    elif K210.mode == 0x02:
        img=sensor.snapshot()                               # 拍摄一张照片
        K210_Find_Blobs(red,2)                              # 找黑色色块 LED标志为1 表示黑色
        motor.control_x = 160                               # 控制目标处于 x轴中心点 160
        Motor_Control(motor,red.cx)                         # 电机占空比控制函数获取电机控制占空比
        motor1.duty(motor.motor1)                           # 将获取到的电机1占空比 装载
        motor2.duty(motor.motor2)                           # 将获取到的电机2占空比 装载

    elif K210.mode == 0x03:
        img=sensor.snapshot()                               # 拍摄一张照片

    else:
        img=sensor.snapshot()                               # 拍摄一张照片

    # 模式选择______________________________________________________

    Point_Control(key)                                      # 按键控制下的目标点获取函数

    lcd.display(img)                                        # LCD 显示图像
    LCD_Show()                                              # LCD 显示按键信息及目标点信息

    #LED_Control(red.led_flag)                              # LED 标记色块识别情况

    UART_Read(RSTM32,uart1)                                 # 串口1 数据接收
    UART_Read(ROpenMV,uart2)                                # 串口2 数据接收

    if timer0.cnt == 0:                                     # 如果 timer0.cnt 等于 0 此步骤的目的是控制打印周期 不要打印的太快
        Print_All()                                         # 打印各参数
        uart1.write(Pack_Data(TSTM32))                      # 串口1 数据发送
        uart2.write(Pack_Data(TOpenMV))                     # 串口2 数据发送
</code></pre>
<p><strong>单片机部分</strong></p>
<p>硬件部分：</p>
<p><code>uartconfig.c</code></p>
<pre><code class="c">#include &quot;uartconfig.h&quot;

/********************************************************************

串口发送数据函数 Data_Transmit

     各参数作用
     DataTransmit *data: 	        		选择要发送的串口发送数据结构体
     UART_HandleTypeDef *huart, :			选择通过哪一个串口发送
     
********************************************************************/
void Data_Transmit(DataTransmit *data, UART_HandleTypeDef *huart)
&#123;
    
    HAL_UART_Transmit(huart, data -&gt; transmit_data, data -&gt; cnt , 0xFFFF);
    
&#125;

/********************************************************************

串口打包发送数据函数 Data_Pack_Transmit

     各参数作用
     DataTransmit *data: 	        		选择要发送的串口发送数据结构体
     UART_HandleTypeDef *huart, :			选择通过哪一个串口发送
     
********************************************************************/
void Data_Pack_Transmit(DataTransmit *data, UART_HandleTypeDef *huart)
&#123;
    
    Data_Pack(data);				
    Data_Transmit(data,huart);			
    
&#125;

/********************************************************************

串口接收1个数据函数 Buffer_Receive

     各参数作用
     DataReceive *data: 					选择通过哪一个串口接收数据结构体接收
     UART_HandleTypeDef *huart, :			选择通过哪一个串口接收 
     
********************************************************************/
uint8_t Buffer_Receive(DataReceive *data, UART_HandleTypeDef *huart)
&#123;
    
    HAL_UART_Receive_IT(huart, &amp;data -&gt; data, 1);
    return data -&gt; data;
    
&#125;
</code></pre>
<p><code>uartconfig.h</code></p>
<pre><code class="c">#ifndef __UARTCONFIG_H
#define __UARTCONFIG_H

#include &quot;stm32f1xx_hal.h&quot;
#include &quot;uartprotocol.h&quot;

// 重命名方便定义
typedef signed char             	int8_t;   
typedef short int               	int16_t;  
typedef int                     	int32_t; 

typedef unsigned char 				uint8_t;
typedef unsigned short int 			uint16_t;
typedef unsigned int            	uint32_t;

// 串口发送相关函数
void Data_Transmit(DataTransmit *data, UART_HandleTypeDef *huart);
void Data_Pack_Transmit(DataTransmit *data, UART_HandleTypeDef *huart);

// 串口接收相关函数
uint8_t Buffer_Receive(DataReceive *data, UART_HandleTypeDef *huart);

#endif
</code></pre>
<p>软件部分：</p>
<p><code>uartprotocol.c</code></p>
<pre><code class="c">#include &quot;uartprotocol.h&quot;

/********************************************************************

串口发送数据结构体初始化函数 Data_Transmit_Init

     各参数作用
     DataTransmit *data: 							选择要初始化的串口发送数据结构体
     head1：			        					帧头1 
     head2：			        					帧头2	
     length：			        					有效数据长度 
     
********************************************************************/
void Data_Transmit_Init(DataTransmit *data, uint8_t head1, uint8_t head2, uint8_t length)
&#123;
    
    data -&gt; head1  = head1;
    data -&gt; head2  = head2;
    data -&gt; length = length;
    data -&gt; cnt		 = length + 4;
    
    for(uint8_t i = 0; i &lt; length; i++)
    &#123;
        
        data -&gt; data[i] = 0;
        
    &#125;
    
    for(uint8_t j = 0; j &lt; length + 4; j++)
    &#123;
        
        data -&gt; transmit_data[j] = 0;
        
    &#125;
    
&#125;

/********************************************************************

串口发送数据打包函数 Data_Pack

     各参数作用
     DataTransmit *data: 							选择要打包的串口发送数据结构体
     
********************************************************************/
void Data_Pack(DataTransmit *data)
&#123;
    
    data -&gt; transmit_data[0] = data -&gt; head1;
    data -&gt; transmit_data[1] = data -&gt; head2;
    data -&gt; transmit_data[2] = data -&gt; length;
    
    for(uint8_t i = 0; i &lt; data -&gt; length; i++)
    &#123;
        
        data -&gt; transmit_data[3+i] = data -&gt; data[i];
        
    &#125;
    
    uint8_t sum = 0;
    
  for(uint8_t j = 0; j &lt; data -&gt; length + 3; j++)
    &#123;
        
        sum = sum + data -&gt; transmit_data[j];
        
    &#125;
    
  data -&gt; transmit_data[data -&gt; length + 3] = sum;
    
&#125;

// 至此串口数据发送函数定义结束 使用例如下
/*

DataTransmit data_transmit_uart;												// 声明全局结构体 data_transmit_uart 这个要放在 main 函数外面

Data_Transmit_Init(&amp;data_transmit_uart,0xAA,0xAA,1);		// main函数中在 while 前 对结构体 data_transmit_uart 进行初始化 帧头都为 0xAA 有效数据长度为 1	

data_transmit_uart.data[0] = 1;													// 将发送的第一个数据赋值为 1 位置不限 

// HAL库 使用方法
// 打包与发送分开
Data_Pack(&amp;data_transmit_uart);													// 对数据进行打包 每次要发送的数据改变的时候 都要重新打包 这个可放在 while 中

Data_Transmit(&amp;data_transmit_uart, USART1);							// 将数据通过USART1 发送

// 打包与发送合并
Data_Pack_Transmit(&amp;data_transmit_uart, USART1);				// 对数据进行打包 并通过USART1 发送

// 固件库 使用方法
// 打包与发送分开
Data_Pack(&amp;data_transmit_uart);													// 对数据进行打包 每次要发送的数据改变的时候 都要重新打包 这个可放在 while 中

Data_Transmit(&amp;data_transmit_uart, USART1);							// 将数据通过USART1 发送

// 打包与发送合并
Data_Pack_Transmit(&amp;data_transmit_uart, USART1);				// 对数据进行打包 并通过USART1 发送

*/
// 至此串口数据发送函数使用例结束 

/********************************************************************

串口接收数据结构体初始化函数 Data_Receive_Init

     各参数作用
     DataReceive *data: 							选择要初始化的串口接收数据结构体
     head1：			        					帧头1
     head2：			        					帧头2
     
********************************************************************/
void Data_Receive_Init(DataReceive *data, uint8_t head1, uint8_t head2)
&#123;
    
    data -&gt; head1  = head1;
    data -&gt; head2  = head2;
    data -&gt; length = 0;
    data -&gt; cnt    = 0;
    data -&gt; state  = 0;
    data -&gt; i      = 0;
    data -&gt; data   = 0;
    
    for(uint8_t j = 0; j &lt; 50; j++)
    &#123;
        
        data -&gt; receive_data[j] = 0;
        
    &#125;
    
&#125;

/********************************************************************

串口接收数据函数 Data_Receive

     各参数作用
     DataReceive *data: 						选择要接收的串口接收数据结构体
   buf:											接收数据
     
********************************************************************/
void Data_Receive(DataReceive *data, uint8_t buf)
&#123;
    
    if(data -&gt; state == 0 &amp;&amp; buf == data -&gt; head1)
    &#123;
        
        data -&gt; state = 1;
        data -&gt; receive_data[0] = buf;
        
    &#125;
    else if(data -&gt; state == 1 &amp;&amp; buf == data -&gt; head2)
    &#123;
        
        data -&gt; state = 2;
        data -&gt; receive_data[1] = buf;
        
    &#125;
    else if(data -&gt; state == 2 &amp;&amp; buf &lt; 40)
    &#123;
        
        data -&gt; state = 3;
        data -&gt; length = buf;
        data -&gt; cnt = buf+4;
        data -&gt; receive_data[2] = buf;
        
    &#125;
    else if(data -&gt; state == 3 &amp;&amp; data -&gt; length &gt; 0)
    &#123;
        
        data -&gt; length = data -&gt; length - 1;
        data -&gt; receive_data[3 + data -&gt; i] = buf;
        data -&gt; i = data -&gt; i + 1;
        
        if(data -&gt; length == 0)
        &#123;
            
            data -&gt; state = 4;
            
        &#125;
        
    &#125;
    else if(data -&gt; state == 4)
    &#123;
        
        data -&gt; receive_data[3 + data -&gt; i] = buf;
        data -&gt; state = 0;
        data -&gt; i = 0;
        
    &#125;
    else
    &#123;
        
        data -&gt; state = 0;
        data -&gt; i = 0;
        
    &#125;
    
&#125;

// 至此串口数据接收函数定义结束 使用例如下
/*

DataReceive data_receive_uart;														// 声明全局结构体 data_receive_uart 这个要放在 main 函数外面

Data_Receive_Init(&amp;data_receive_uart,0xAA,0xAA);					// main函数中在 while 前 对结构体 data_receive_uart 进行初始化 设置帧头为 0xAA

// HAL库 使用方法
Buffer_Receive(&amp;huart1,&amp;data_receive_uart);							  // main的函数在 while 前 HAL库需要接收一次 使之可以进入中断回调

// 串口中断回调函数
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)		// 中断回调函数中调用即可 函数 HAL_UART_RxCpltCallback 是一个弱定义 可以在 main.c 的 USER CODE BEGIN 4 中进行重写
&#123;

    if( huart == &amp;huart1 )																	// 检测到串口中断1
    &#123;

        Data_Receive(&amp;data_receive_uart,Buffer_Receive(&amp;huart1,&amp;data_receive_uart));

    &#125;

&#125;

// 固件库 使用方法 直接将中断函数复制到 main.c 下面即可

// 串口1 中断函数
void USART1_IRQHandler(void)
&#123;
    
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) 													// 判断接收数据寄存器是否有数据
    &#123;
            
            Data_Receive(&amp;data_receive_uart, USART_ReceiveData(USART1));									// 从 串口1 接收1个数据
                
            USART_ClearFlag(USART1,USART_IT_RXNE);																				// 清空中断标志 准备下一次接收
            
    &#125;
    
&#125;

*/
// 至此串口数据接收函数使用例结束 

// 以下为串口接收数据解析函数 此类函数可自行定义 增删改变量 方法不唯一
/********************************************************************

串口接收数据结构体初始化函数 Target_Init

     各参数作用
     TargetAttribute *target: 			选择要初始化的结构体
     
********************************************************************/
void Target_Init(TargetProperty *target)
&#123;
    
    target -&gt; x     = 0;
    target -&gt; y     = 0;
    target -&gt; color = 0;
    target -&gt; shape = 0;
    target -&gt; flag  = 0;
    
&#125;

/********************************************************************

串口接收数据解析函数 Target_Parse

     各参数作用	
   DataReceive *data: 						选择被解析的结构体
     TargetProperty *target: 			  选择解析完成保存的结构体
     
********************************************************************/
void Target_Parse(DataReceive *data, TargetProperty *target)
&#123;
    
    uint8_t sum = 0;
    uint8_t i   = 0;
    
    while(i &lt; data -&gt; cnt - 1)
    &#123;
        
        sum = sum + data -&gt; receive_data[i];
        i = i + 1;
        
    &#125;
    
    if(sum == data -&gt; receive_data[data -&gt; cnt - 1])
    &#123;
        
        target -&gt; x     = data -&gt; receive_data[3]*256 + data -&gt; receive_data[4];
        target -&gt; y     = data -&gt; receive_data[5]*256 + data -&gt; receive_data[6];
        target -&gt; color = data -&gt; receive_data[7];
        target -&gt; shape = data -&gt; receive_data[8];
        target -&gt; flag  = data -&gt; receive_data[9];
        
    &#125;
    
&#125;

// 至此数据解析函数定义结束 使用例如下
/*

TargetProperty target;											  					// 声明全局结构体 target 这个要放在 main 函数外面

Target_Init(&amp;target);																		// main函数中在 while 前 对结构体 target 进行初始化 

Target_Parse(&amp;data_receive_uart,&amp;target);								// 解析接收数据 可以放在 while 中 也可放在其他地方 不唯一

*/
// 解析函数可根据自身需求自由定义 方法不唯一

// 库函数版本 测试范例 第一个使用UART1 第二个使用UART1、UART2、UART3 
// 测试 main.c 如下 初始化 一个UART 并接收数据 可复制该代码 进行测试 
/*

#include &quot;uartconfig.h&quot;
#include &quot;uartprotocol.h&quot;

#include &quot;timer.h&quot;

// 串口发送
DataTransmit data_transmit_uart1;												// 声明全局结构体 data_transmit_uart1 这个要放在 main 函数外面

// 串口接收
DataReceive data_receive_uart1;													// 声明全局结构体 data_receive_uart1 这个要放在 main 函数外面

// 被发送数据
TargetProperty t1;											  							// 声明全局结构体 t1 这个要放在 main 函数外面

// 接收数据解析
TargetProperty target1;											  					// 声明全局结构体 target1 这个要放在 main 函数外面

// 定时器任务队列参数
uint8_t tim_task = 0;																		// 任务序号
uint8_t task_flag = 0;																	// 任务完成标志 0完成 1未完成

// 运行任务函数声明
void Run_Task(void);

int main(void)
&#123;
    
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	 			// 设置NVIC中断分组2 2位抢占优先级 2位响应优先级 即可设置 0-3 抢占优先级 0-3 子优先级 2位就是2的2次方 
    
    LED_Init();																						// LED 初始化 用于观察程序是否正常运行
    
    // 定时器3 初始化
    Init_TIM3(9999,71,0,1);															  // 定时器3 初始化 计数值 9999 分频系数 71 抢占优先级 0 子优先级 1 定时时间 （72M/(71+1)）/(9999+1)=100 Hz 即 0.01s 产生一次中断
    
    // 串口发送初始化
    Init_UART1(115200,1,1);																// 串口1 初始化 波特率115200 抢占优先级1 子优先级1  
    
    Data_Transmit_Init(&amp;data_transmit_uart1,0xAA,0xAA,7);	// main函数中在 while 前 对结构体 data_transmit_uart1 进行初始化 帧头都为 0xAA 有效数据长度为 7	
    
    // 串口接收初始化
    Data_Receive_Init(&amp;data_receive_uart1,0xAA,0xAA);			// main函数中在 while 前 对结构体 data_receive_uart1 进行初始化 设置帧头为 0xAA

  // 被发送数据初始化
    Target_Init(&amp;t1);																			// main函数中在 while 前 对结构体 t1 进行初始化 

    // 接收数据解析初始化
    Target_Init(&amp;target1);																// main函数中在 while 前 对结构体 target1 进行初始化  
    
    while(1)
    &#123;
        
        Run_Task();																					// 运行任务
    
    &#125;
&#125;

// 运行任务函数
void Run_Task(void)
&#123;
    
    if(tim_task == 0 &amp;&amp; task_flag == 1)
    &#123;
        
        data_transmit_uart1.data[0] = t1.x/256;											
        data_transmit_uart1.data[1] = t1.x%256;											
        data_transmit_uart1.data[2] = t1.y/256;											
        data_transmit_uart1.data[3] = t1.y%256;											
        data_transmit_uart1.data[4] = t1.color;											
        data_transmit_uart1.data[5] = t1.shape;											
        data_transmit_uart1.data[6] = t1.flag;	
        
        Data_Pack_Transmit(&amp;data_transmit_uart1, USART1);		// 对数据进行打包 并通过USART1 发送
        
        GPIO_SetBits(GPIOB,GPIO_Pin_5);
        
        task_flag = 0;
        
    &#125;
    else if(tim_task == 1 &amp;&amp; task_flag == 1)
    &#123;
        
        Target_Parse(&amp;data_receive_uart1,&amp;target1);					// 解析 data_receive_uart1 接收数据 给 target1
        
        GPIO_ResetBits(GPIOB,GPIO_Pin_5);
        
        task_flag = 0;
        
    &#125;
&#125;

// 定时器3 中断函数
void TIM3_IRQHandler(void)   											  		// TIM3中断服务函数
&#123;
    
    if(TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) 		// 检查TIM3更新中断发生与否
    &#123;
            
        if(tim_task &lt; 1)
        &#123;
            
            tim_task = tim_task + 1;													// 任务切换
            task_flag = 1;																		// 任务完成标志 0完成 1未完成 每次只做一次任务
            
        &#125;
        else
        &#123;
            
            tim_task = 0;																			// 重头开始执行任务
            task_flag = 1;																		// 任务完成标志 0完成 1未完成 每次只做一次任务
            
        &#125;
        
        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);  				// 清除TIM3更新中断标志 
                
    &#125;
    
&#125;

// 串口1 中断函数
void USART1_IRQHandler(void)
&#123;
    
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) 													// 判断接收数据寄存器是否有数据
    &#123;
            
            Data_Receive(&amp;data_receive_uart1, USART_ReceiveData(USART1));									// 从 串口1 接收1个数据
                
            USART_ClearFlag(USART1,USART_IT_RXNE);																				// 清空中断标志 准备下一次接收
            
    &#125;
    
&#125;

*/

// 测试 main.c 如下 初始化 三个UART 并接收数据 可复制该代码 进行测试 
/*

#include &quot;uartconfig.h&quot;
#include &quot;uartprotocol.h&quot;

#include &quot;timer.h&quot;

// 串口发送
DataTransmit data_transmit_uart1;												// 声明全局结构体 data_transmit_uart1 这个要放在 main 函数外面
DataTransmit data_transmit_uart2;												// 声明全局结构体 data_transmit_uart2 这个要放在 main 函数外面
DataTransmit data_transmit_uart3;												// 声明全局结构体 data_transmit_uart3 这个要放在 main 函数外面

// 串口接收
DataReceive data_receive_uart1;													// 声明全局结构体 data_receive_uart1 这个要放在 main 函数外面
DataReceive data_receive_uart2;													// 声明全局结构体 data_receive_uart2 这个要放在 main 函数外面
DataReceive data_receive_uart3;													// 声明全局结构体 data_receive_uart3 这个要放在 main 函数外面

// 被发送数据
TargetProperty t1;											  							// 声明全局结构体 t1 这个要放在 main 函数外面
TargetProperty t2;											  							// 声明全局结构体 t2 这个要放在 main 函数外面
TargetProperty t3;											  							// 声明全局结构体 t3 这个要放在 main 函数外面

// 接收数据解析
TargetProperty target1;											  					// 声明全局结构体 target1 这个要放在 main 函数外面
TargetProperty target2;											  					// 声明全局结构体 target2 这个要放在 main 函数外面
TargetProperty target3;											  					// 声明全局结构体 target3 这个要放在 main 函数外面

// 定时器任务队列参数
uint8_t tim_task = 0;																		// 任务序号
uint8_t task_flag = 0;																	// 任务完成标志 0完成 1未完成

// 运行任务函数声明
void Run_Task(void);

int main(void)
&#123;
    
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	 			// 设置NVIC中断分组2 2位抢占优先级 2位响应优先级 即可设置 0-3 抢占优先级 0-3 子优先级 2位就是2的2次方 
    
    LED_Init();																						// LED 初始化 用于观察程序是否正常运行
    
    // 定时器3 初始化
    Init_TIM3(9999,71,0,1);															  // 定时器3 初始化 计数值 9999 分频系数 71 抢占优先级 0 子优先级 1 定时时间 （72M/(71+1)）/(9999+1)=100 Hz 即 0.01s 产生一次中断
    
    // 串口发送初始化
    Init_UART1(115200,1,1);																// 串口1 初始化 波特率115200 抢占优先级1 子优先级1 
    Init_UART2(115200,1,1);																// 串口2 初始化 波特率115200 抢占优先级1 子优先级1 
    Init_UART3(115200,1,1);																// 串口3 初始化 波特率115200 抢占优先级1 子优先级1 
    
    Data_Transmit_Init(&amp;data_transmit_uart1,0xAA,0xAA,7);	// main函数中在 while 前 对结构体 data_transmit_uart1 进行初始化 帧头都为 0xAA 有效数据长度为 7	

    Data_Transmit_Init(&amp;data_transmit_uart2,0xBB,0xBB,7);	// main函数中在 while 前 对结构体 data_transmit_uart2 进行初始化 帧头都为 0xBB 有效数据长度为 7	
    
    Data_Transmit_Init(&amp;data_transmit_uart3,0xCC,0xCC,7);	// main函数中在 while 前 对结构体 data_transmit_uart3 进行初始化 帧头都为 0xCC 有效数据长度为 7	
    
    // 串口接收初始化
    Data_Receive_Init(&amp;data_receive_uart1,0xAA,0xAA);			// main函数中在 while 前 对结构体 data_receive_uart1 进行初始化 设置帧头为 0xAA
    Data_Receive_Init(&amp;data_receive_uart2,0xBB,0xBB);			// main函数中在 while 前 对结构体 data_receive_uart2 进行初始化 设置帧头为 0xBB
    Data_Receive_Init(&amp;data_receive_uart3,0xCC,0xCC);			// main函数中在 while 前 对结构体 data_receive_uart3 进行初始化 设置帧头为 0xCC

  // 被发送数据初始化
    Target_Init(&amp;t1);																			// main函数中在 while 前 对结构体 t1 进行初始化 
    Target_Init(&amp;t2);																			// main函数中在 while 前 对结构体 t2 进行初始化 
    Target_Init(&amp;t3);																			// main函数中在 while 前 对结构体 t3 进行初始化 

    // 接收数据解析初始化
    Target_Init(&amp;target1);																// main函数中在 while 前 对结构体 target1 进行初始化 
    Target_Init(&amp;target2);																// main函数中在 while 前 对结构体 target2 进行初始化 
    Target_Init(&amp;target3);																// main函数中在 while 前 对结构体 target3 进行初始化 
    
    while(1)
    &#123;
        
        Run_Task();																					// 运行任务
    
    &#125;
&#125;

// 运行任务函数
void Run_Task(void)
&#123;
    
    if(tim_task == 0 &amp;&amp; task_flag == 1)
    &#123;
        
        data_transmit_uart1.data[0] = t1.x/256;											
        data_transmit_uart1.data[1] = t1.x%256;											
        data_transmit_uart1.data[2] = t1.y/256;											
        data_transmit_uart1.data[3] = t1.y%256;											
        data_transmit_uart1.data[4] = t1.color;											
        data_transmit_uart1.data[5] = t1.shape;											
        data_transmit_uart1.data[6] = t1.flag;	
        
        Data_Pack_Transmit(&amp;data_transmit_uart1, USART1);		// 对数据进行打包 并通过USART1 发送
        
        GPIO_SetBits(GPIOB,GPIO_Pin_5);
        
        task_flag = 0;
        
    &#125;
    else if(tim_task == 1 &amp;&amp; task_flag == 1)
    &#123;
        
        data_transmit_uart2.data[0] = t2.x/256;											
        data_transmit_uart2.data[1] = t2.x%256;											
        data_transmit_uart2.data[2] = t2.y/256;											
        data_transmit_uart2.data[3] = t2.y%256;											
        data_transmit_uart2.data[4] = t2.color;											
        data_transmit_uart2.data[5] = t2.shape;											
        data_transmit_uart2.data[6] = t2.flag;
        
        Data_Pack_Transmit(&amp;data_transmit_uart2, USART2);		// 对数据进行打包 并通过USART2 发送
        
        GPIO_ResetBits(GPIOB,GPIO_Pin_5);
        
        task_flag = 0;
        
    &#125;
    else if(tim_task == 2 &amp;&amp; task_flag == 1)
    &#123;
        
        data_transmit_uart3.data[0] = t3.x/256;											
        data_transmit_uart3.data[1] = t3.x%256;											
        data_transmit_uart3.data[2] = t3.y/256;											
        data_transmit_uart3.data[3] = t3.y%256;											
        data_transmit_uart3.data[4] = t3.color;											
        data_transmit_uart3.data[5] = t3.shape;											
        data_transmit_uart3.data[6] = t3.flag;	
        
        Data_Pack_Transmit(&amp;data_transmit_uart3, USART3);		// 对数据进行打包 并通过USART3 发送
        
        GPIO_SetBits(GPIOB,GPIO_Pin_5);
        
        task_flag = 0;
        
    &#125;
    else if(tim_task == 3 &amp;&amp; task_flag == 1)
    &#123;
        
        Target_Parse(&amp;data_receive_uart1,&amp;target1);					// 解析 data_receive_uart1 接收数据 给 target1
        Target_Parse(&amp;data_receive_uart2,&amp;target2);					// 解析 data_receive_uart2 接收数据 给 target2
        Target_Parse(&amp;data_receive_uart3,&amp;target3);					// 解析 data_receive_uart3 接收数据 给 target3
        
        GPIO_ResetBits(GPIOB,GPIO_Pin_5);
        
        task_flag = 0;
        
    &#125;
&#125;

// 定时器3 中断函数
void TIM3_IRQHandler(void)   											  		// TIM3中断服务函数
&#123;
    
    if(TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) 		// 检查TIM3更新中断发生与否
    &#123;
            
        if(tim_task &lt; 3)
        &#123;
            
            tim_task = tim_task + 1;													// 任务切换
            task_flag = 1;																		// 任务完成标志 0完成 1未完成 每次只做一次任务
            
        &#125;
        else
        &#123;
            
            tim_task = 0;																			// 重头开始执行任务
            task_flag = 1;																		// 任务完成标志 0完成 1未完成 每次只做一次任务
            
        &#125;
        
        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);  				// 清除TIM3更新中断标志 
                
    &#125;
    
&#125;

// 串口1 中断函数
void USART1_IRQHandler(void)
&#123;
    
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) 													// 判断接收数据寄存器是否有数据
    &#123;
            
            Data_Receive(&amp;data_receive_uart1, USART_ReceiveData(USART1));									// 从 串口1 接收1个数据
                
            USART_ClearFlag(USART1,USART_IT_RXNE);																				// 清空中断标志 准备下一次接收
            
    &#125;
    
&#125;

// 串口2 中断函数
void USART2_IRQHandler(void)
&#123;
    
    if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) 													// 判断接收数据寄存器是否有数据
    &#123;
            
            Data_Receive(&amp;data_receive_uart2, USART_ReceiveData(USART2));									// 从 串口2 接收1个数据
                
            USART_ClearFlag(USART2,USART_IT_RXNE);																				// 清空中断标志 准备下一次接收
            
    &#125;
    
&#125;

// 串口3 中断函数
void USART3_IRQHandler(void)
&#123;
    
    if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) 													// 判断接收数据寄存器是否有数据
    &#123;
            
            Data_Receive(&amp;data_receive_uart3, USART_ReceiveData(USART3));									// 从 串口3 接收1个数据
                
            USART_ClearFlag(USART3,USART_IT_RXNE);																				// 清空中断标志 准备下一次接收
            
    &#125;
    
&#125;

*/
</code></pre>
<p><code>uartprotocol.h</code></p>
<pre><code class="c">#ifndef __UARTPROTOCOL_H
#define __UARTPROTOCOL_H

// 重命名方便定义
typedef signed char             	int8_t;   
typedef short int               	int16_t;  
typedef int                     	int32_t; 

typedef unsigned char 				uint8_t;
typedef unsigned short int 			uint16_t;
typedef unsigned int            	uint32_t;

// 串口发送相关结构体
typedef struct
&#123;
    
    uint8_t	head1;							// 帧头1
    uint8_t	head2;							// 帧头2
    uint8_t length;							// 有效数据长度
    uint8_t cnt;							// 总数据长度
    uint8_t data[40];						// 有效数据数组
    uint8_t transmit_data[50];				// 实际发送的数组 附带上帧头1 帧头2 有效数据长度位 校验位
    
&#125;DataTransmit;

// 串口发送相关函数
void Data_Transmit_Init(DataTransmit *data, uint8_t head1, uint8_t head2, uint8_t length);
void Data_Pack(DataTransmit *data);

// 串口接收相关结构体
typedef struct
&#123;
    
    uint8_t	head1;							// 帧头1
    uint8_t	head2;							// 帧头2
    uint8_t length;							// 有效数据长度
    uint8_t cnt;							// 总数据长度
    uint8_t state;							// 接收状态
    uint8_t i;								// 有效数据下标
    uint8_t data;							// 接收数据缓冲位
    uint8_t receive_data[50];				// 实际接收的数组 附带上帧头1 帧头2 有效数据长度位 校验位
    
&#125;DataReceive;

// 串口接收相关函数
void Data_Receive_Init(DataReceive *data, uint8_t head1, uint8_t head2);
void Data_Receive(DataReceive *data, uint8_t buf);

// 接收数据解析相关结构体
typedef struct
&#123;
    
    uint16_t	x;						    // 目标x轴坐标
    uint16_t	y;							// 目标y轴坐标
    uint8_t   color;						// 目标颜色标志位
    uint8_t   shape;						// 目标形状标志位
    uint8_t   flag;							// 目标标志位
    
&#125;TargetProperty;

// 接收数据解析相关函数
void Target_Init(TargetProperty *target);
void Target_Parse(DataReceive *data, TargetProperty *target);

#endif
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/dbc3070d7cef4eacacf8360cda74fdf1?pvs=21">图像矩形顶角获取</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">GaGa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/09/19/K210%E6%91%84%E5%83%8F%E5%A4%B4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2023/09/19/K210%E6%91%84%E5%83%8F%E5%A4%B4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">嗨！这里是康康的裤兜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_1.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/14/MINI_OSCILLOGRAPH/" title="MINI_OSCILLOGRAPH"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MINI_OSCILLOGRAPH</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/06/Platforms-Registry-PIO-Core-Call-Error-HTTPClientError-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="VScode中Platformio的library界面卡死在loading...的解决办法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_5.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">VScode中Platformio的library界面卡死在loading...的解决办法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"></div><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/bear.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">GaGa</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/allrightcallmeGaGa"><i class="fab fa-github"></i><span>🛴前往肚兜...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/allrightcallmeGaGa" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:allrightgohome@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%90%AF%E7%94%A8%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E6%91%84%E5%83%8F%E5%A4%B4"><span class="toc-number">1.</span> <span class="toc-text">一、启用并初始化摄像头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">代码实例：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BA%86%E5%AF%B9%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">引入了对库的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E7%94%B5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">上电操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81MicroPython-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">二、MicroPython 背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E4%BB%A3%E7%A0%81%E7%B4%A0%E5%85%BB"><span class="toc-number">2.1.</span> <span class="toc-text">Python代码素养</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">Python语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E8%BF%9B"><span class="toc-number">2.1.2.</span> <span class="toc-text">缩进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%AE%BD"><span class="toc-number">2.1.3.</span> <span class="toc-text">行宽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E8%A1%8C"><span class="toc-number">2.1.4.</span> <span class="toc-text">空行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C"><span class="toc-number">2.1.5.</span> <span class="toc-text">换行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%8F%B7"><span class="toc-number">2.1.6.</span> <span class="toc-text">引号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MicroPython%EF%BC%88Python3%EF%BC%89-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">MicroPython（Python3） 基本语法#</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">list 列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple-%E5%85%83%E7%BB%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">tuple 元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.2.4.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.5.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.6.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">2.2.7.</span> <span class="toc-text">切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.8.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">2.2.9.</span> <span class="toc-text">模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%AELED"><span class="toc-number">2.3.</span> <span class="toc-text">点亮LED</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FPIOA%EF%BC%88%E7%8E%B0%E5%9C%BA%E5%8F%AF%E7%BC%96%E7%A8%8BIO%E9%98%B5%E5%88%97%EF%BC%89%EF%BC%9A%E5%A4%96%E8%AE%BE%E5%88%B0%E5%BC%95%E8%84%9A%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">FPIOA（现场可编程IO阵列）：外设到引脚的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81K210%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">三、K210外设配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sensor"><span class="toc-number">3.1.</span> <span class="toc-text">sensor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#image"><span class="toc-number">3.2.</span> <span class="toc-text">image</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWM"><span class="toc-number">3.4.</span> <span class="toc-text">PWM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">四、模块代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E8%A7%89%E5%B7%A1%E7%BA%BF"><span class="toc-number">4.1.</span> <span class="toc-text">视觉巡线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">数字识别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">4.3.</span> <span class="toc-text">串口通信</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By GaGa</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script src="/js/sun_moon.js" async></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>